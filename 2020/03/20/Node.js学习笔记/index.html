<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Yokin的博客">
    <meta name="keyword"  content="前端技术分享">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Node.js学习笔记 - Yokin的博客 | Yokin&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 重剑无锋,大巧不工! </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Yokin</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Node-js学习笔记"><span class="toc-text">Node.js学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Nodejs概述"><span class="toc-text">Nodejs概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#服务器端开发基础"><span class="toc-text">服务器端开发基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node是什么"><span class="toc-text">Node是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node能做什么？"><span class="toc-text">Node能做什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js模块化"><span class="toc-text">Node.js模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript开发弊端"><span class="toc-text">JavaScript开发弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块化开发"><span class="toc-text">模块化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-js中模块化开发规范"><span class="toc-text">Node.js中模块化开发规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exports-和-module-exports-的区别"><span class="toc-text">exports 和 module.exports 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#npm常用命令"><span class="toc-text">npm常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统模块"><span class="toc-text">系统模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三方模块"><span class="toc-text">第三方模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第三方模块nodemon"><span class="toc-text">第三方模块nodemon</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三方模块-nrm"><span class="toc-text">第三方模块 nrm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json文件"><span class="toc-text">package.json文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#node-modules文件夹的问题"><span class="toc-text">node_modules文件夹的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#package-json文件的作用"><span class="toc-text">package.json文件的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#项目依赖"><span class="toc-text">项目依赖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#开发依赖"><span class="toc-text">开发依赖</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#package-lock-json文件的作用"><span class="toc-text">package-lock.json文件的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-js中模块加载机制"><span class="toc-text">Node.js中模块加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#模块查找规则-当模块拥有路径但没有后缀时"><span class="toc-text">模块查找规则-当模块拥有路径但没有后缀时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#模块查找规则-当模块没有路径且没有后缀时"><span class="toc-text">模块查找规则-当模块没有路径且没有后缀时</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node创建web服务器"><span class="toc-text">Node创建web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET请求参数"><span class="toc-text">GET请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST请求参数"><span class="toc-text">POST请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由"><span class="toc-text">路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js异步编程"><span class="toc-text">Node.js异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#回调函数"><span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js中的异步API"><span class="toc-text">Node.js中的异步API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步函数async"><span class="toc-text">异步函数async</span></a></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 重剑无锋,大巧不工! </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Node.js学习笔记
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-03-20 21:24:33</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Node.js" title="Node.js">Node.js</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="Node-js学习笔记"><a href="#Node-js学习笔记" class="headerlink" title="Node.js学习笔记"></a>Node.js学习笔记</h1><h2 id="Nodejs概述"><a href="#Nodejs概述" class="headerlink" title="Nodejs概述"></a>Nodejs概述</h2><h3 id="服务器端开发基础"><a href="#服务器端开发基础" class="headerlink" title="服务器端开发基础"></a>服务器端开发基础</h3><p>学习服务端开发能够和后端程序员更加紧密的配合，网站业务逻辑前置，学习前端技术需要后端技术支撑（Ajax），同时扩宽知识视野，能够站在更高的角度审视整个项目。</p>
<p>服务器端开发要做的两件事分别为实现网站的业务逻辑和数据的增删改查。</p>
<h3 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么?"></a>Node是什么?</h3><p>Node是一个基于Chrome V8引擎的JavaScript代码运行环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 的组成</span></span><br><span class="line">JavaScript 由三部分组成，ECMAScript，DOM，BOM。</span><br><span class="line">Node.js是由ECMAScript及Node 环境提供的一些附加API组成的，包括文件、网络、路径等等一些更加强大的 API,在Node.js中没有DOM和BOM。</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.js基础语法</span></span><br><span class="line">所有ECMAScript语法在Node环境中都可以使用。</span><br><span class="line">在Node环境下执行代码，使用Node命令执行后缀为.js的文件即可</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.js全局对象global</span></span><br><span class="line">在浏览器中全局对象是<span class="built_in">window</span>，在Node中全局对象是global。</span><br><span class="line">Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。</span><br><span class="line"><span class="built_in">console</span>.log()     在控制台中输出</span><br><span class="line">setTimeout()     设置超时定时器</span><br><span class="line">clearTimeout()  清除超时时定时器</span><br><span class="line">setInterval()      设置间歇定时器</span><br><span class="line">clearInterval()   清除间歇定时器</span><br></pre></td></tr></table></figure>

<h3 id="Node能做什么？"><a href="#Node能做什么？" class="headerlink" title="Node能做什么？"></a>Node能做什么？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Web服务器</span><br><span class="line">命令行工具</span><br><span class="line">  * npm(node)</span><br><span class="line">  * git(C语言)</span><br><span class="line">  * hexo(node)</span><br><span class="line">  * 。。。</span><br><span class="line">对于前端开发工程师来讲,自己写的很少,主要是使用别人第三方的工具，接触Node最多的是它的命令行工具webpack、gulp、npm等。</span><br></pre></td></tr></table></figure>

<h2 id="Node-js模块化"><a href="#Node-js模块化" class="headerlink" title="Node.js模块化"></a>Node.js模块化</h2><h3 id="JavaScript开发弊端"><a href="#JavaScript开发弊端" class="headerlink" title="JavaScript开发弊端"></a>JavaScript开发弊端</h3><p>JavaScript在使用时存在两大问题，文件依赖和命名冲突。</p>
<h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>Node中的模块分为系统模块(又称为核心模块)、第三方模块和自定义模块,一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。</p>
<h3 id="Node-js中模块化开发规范"><a href="#Node-js中模块化开发规范" class="headerlink" title="Node.js中模块化开发规范"></a>Node.js中模块化开发规范</h3><p>Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到<br>模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块成员导出</span></span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line">  <span class="comment">// 在模块内部定义变量</span></span><br><span class="line"> <span class="keyword">let</span> version = <span class="number">1.0</span>;</span><br><span class="line"> <span class="comment">// 在模块内部定义方法</span></span><br><span class="line"> <span class="keyword">const</span> sayHi = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`您好, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"> <span class="comment">// 向模块外部导出数据 </span></span><br><span class="line"> exports.version = version;</span><br><span class="line"> exports.sayHi = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块成员的导入</span></span><br><span class="line"><span class="comment">// b.js 导入模块时后缀可以省略</span></span><br><span class="line">  <span class="comment">// 在b.js模块中导入模块a</span></span><br><span class="line"> <span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">'./b.js'</span>);</span><br><span class="line">  <span class="comment">// 输出b模块中的version变量</span></span><br><span class="line"> <span class="built_in">console</span>.log(a.version);</span><br><span class="line">  <span class="comment">// 调用b模块中的sayHi方法 并输出其返回值</span></span><br><span class="line"> <span class="built_in">console</span>.log(a.sayHi(<span class="string">'黑马讲师'</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块成员导出的另一种方式</span></span><br><span class="line"><span class="comment">// exports是module.exports的别名(地址引用关系)，导出对象最终以module.exports为准</span></span><br><span class="line"><span class="built_in">module</span>.exports.version = version;</span><br><span class="line"><span class="built_in">module</span>.exports.sayHi = sayHi;</span><br></pre></td></tr></table></figure>

<h3 id="exports-和-module-exports-的区别"><a href="#exports-和-module-exports-的区别" class="headerlink" title="exports 和 module.exports 的区别"></a>exports 和 module.exports 的区别</h3><ul>
<li><p>每个模块中都有一个 module 对象</p>
</li>
<li><p>module 对象中有一个 exports 对象</p>
</li>
<li><p>我们可以把需要导出的成员都挂载到 module.exports 接口对象中</p>
</li>
<li><p>也就是：<code>moudle.exports.xxx = xxx</code> 的方式</p>
</li>
<li><p>但是每次都 <code>moudle.exports.xxx = xxx</code> 很麻烦，点儿的太多了</p>
</li>
<li><p>所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：<code>exports</code></p>
</li>
<li><p><code>exports === module.exports</code> 结果为  <code>true</code></p>
</li>
<li><p>所以对于：<code>moudle.exports.xxx = xxx</code> 的方式 完全可以：<code>expots.xxx = xxx</code></p>
</li>
<li><p>当一个模块需要导出单个成员的时候，这个时候<strong>必须使用</strong>：<code>module.exports = xxx</code> 的方式</p>
</li>
<li><p>不要使用 <code>exports = xxx</code> 不管用</p>
</li>
<li><p>因为每个模块最终向外 <code>return</code> 的是 <code>module.exports</code></p>
</li>
<li><p>而 <code>exports</code> 只是 <code>module.exports</code> 的一个引用</p>
</li>
<li><p>所以即便你为 <code>exports = xx</code> 重新赋值，也不会影响 <code>module.exports</code></p>
</li>
<li><p>但是有一种赋值方式比较特殊：<code>exports = module.exports</code> 这个用来重新建立引用关系的</p>
</li>
</ul>
<h3 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ npm init</span><br><span class="line">+ npm init -y 可以跳过向导,快速生成</span><br><span class="line">+ npm install</span><br><span class="line">  - 一次性把dependencies选项中的依赖项全部安装</span><br><span class="line">  - npm i</span><br><span class="line">+ npm install 包名</span><br><span class="line">  - 只下载</span><br><span class="line">  - npm i 包名</span><br><span class="line">+ npm install --save 包名</span><br><span class="line">  - 下载并保存依赖项（package.json文件中的dependencies选项中）</span><br><span class="line">  - npm i -S 包名</span><br><span class="line">+ npm uninstall 包名</span><br><span class="line">  - 只删除,如果有依赖项会依然保存</span><br><span class="line">  - npm un 包名</span><br><span class="line">+ npm uninstall --save 包名</span><br><span class="line">  - 删除的同时也会把依赖信息去掉</span><br><span class="line">  - npm un -S 包名</span><br><span class="line">+ npm help</span><br><span class="line">  - 查看使用帮助</span><br><span class="line">+ npm 命令 --help</span><br><span class="line">  - 查看指定命令的使用帮助</span><br><span class="line">  - 假如忘记了uninstall命令的简写,这个时候,可以输入<span class="string">`npm uninstall --help`</span>来查看使用帮助</span><br></pre></td></tr></table></figure>

<h3 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h3><p>Node运行环境提供的API. 因为这些API都是以模块化的方式进行开发的, 所以我们又称Node运行环境提供的API为系统模块。例如fs模块就是系统模块，其拥有读取文件、写入文件和创建文件夹等功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 写入文件内容</span></span><br><span class="line"> <span class="keyword">const</span> content = <span class="string">'&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;'</span>;</span><br><span class="line"> fs.writeFile(<span class="string">'../index.html'</span>, content, err =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (err != <span class="literal">null</span>) &#123; </span><br><span class="line">       <span class="built_in">console</span>.log(err);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统模块path 路径操作</span></span><br><span class="line"><span class="comment">// 路径拼接语法</span></span><br><span class="line">path.join(<span class="string">'路径'</span>, <span class="string">'路径'</span>, ...)</span><br><span class="line"><span class="comment">// 导入path模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 路径拼接</span></span><br><span class="line"><span class="keyword">let</span> finialPath = path.join(<span class="string">'E'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c.css'</span>);</span><br><span class="line"><span class="comment">// 输出结果 E\a\b\c.css</span></span><br><span class="line"><span class="built_in">console</span>.log(finialPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对路径VS绝对路径 </span></span><br><span class="line">大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录,在读取文件或者设置文件路径时都会选择绝对路径,要想解决这个问题,我们可以使用__dirname获取当前文件所在的绝对路径</span><br></pre></td></tr></table></figure>

<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><p>别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。第三方模块的存储和分发仓库：<code>npmjs.com</code><br>        第三方模块有两种存在形式：</p>
<ul>
<li><p>以js文件的形式存在，提供实现项目具体功能的API接口。</p>
</li>
<li><p>以命令行工具形式存在，辅助项目开发</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第三方模块</span></span><br><span class="line">npm (node package manager) ： node的第三方模块管理工具</span><br><span class="line">下载：npm install 模块名称</span><br><span class="line">卸载：npm unintall package 模块名称</span><br><span class="line"><span class="comment">// 全局安装与本地安装</span></span><br><span class="line">命令行工具：全局安装</span><br><span class="line">库文件：本地安装</span><br></pre></td></tr></table></figure>

<h4 id="第三方模块nodemon"><a href="#第三方模块nodemon" class="headerlink" title="第三方模块nodemon"></a>第三方模块nodemon</h4><p>nodemon是一个命令行工具，用以辅助项目开发。在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐。但Nodemon模块可以帮助我们解决这个问题.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用步骤</span><br><span class="line"><span class="number">1.</span>使用npm install nodemon –g 下载它</span><br><span class="line"><span class="number">2.</span>在命令行工具中用nodemon命令替代node命令执行文件</span><br></pre></td></tr></table></figure>

<h4 id="第三方模块-nrm"><a href="#第三方模块-nrm" class="headerlink" title="第三方模块 nrm"></a>第三方模块 nrm</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nrm ( npm registry manager )：npm下载地址切换工具</span><br><span class="line">npm默认的下载地址在国外，国内下载速度慢，要想提高下载速度,我们可以使用nrm切换npm下载地址。</span><br><span class="line"><span class="comment">// 使用步骤</span></span><br><span class="line">使用npm install nrm –g 下载它</span><br><span class="line">查询可用下载地址列表 nrm ls</span><br><span class="line">切换npm下载地址 nrm use 下载地址名称</span><br></pre></td></tr></table></figure>

<h3 id="package-json文件"><a href="#package-json文件" class="headerlink" title="package.json文件"></a><code>package.json</code>文件</h3><h4 id="node-modules文件夹的问题"><a href="#node-modules文件夹的问题" class="headerlink" title="node_modules文件夹的问题"></a><code>node_modules</code>文件夹的问题</h4><p>1.文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢. </p>
<p>2.复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错</p>
<h4 id="package-json文件的作用"><a href="#package-json文件的作用" class="headerlink" title="package.json文件的作用"></a><code>package.json</code>文件的作用</h4><p><code>package.json</code>是项目描述文件，解决了上述<code>node_modules</code>文件夹的问题，其记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。</p>
<p>使用<code>npm init -y</code>命令生成。</p>
<h5 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h5><p>在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖</p>
<p>使用<code>npm install</code>包名命令下载的文件会默认被添加到 <code>package.json</code>文件的<code>dependencies</code>字段中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="string">"jquery"</span>: <span class="string">"^3.3.1“</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="开发依赖"><a href="#开发依赖" class="headerlink" title="开发依赖"></a>开发依赖</h5><p>在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖</p>
<p>使用<code>npm install</code>包名<code>--save-dev</code>命令将包添加到<code>package.json</code>文件的<code>devDependencies</code>字段中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">       <span class="string">"gulp"</span>: <span class="string">"^3.9.1“</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="package-lock-json文件的作用"><a href="#package-lock-json文件的作用" class="headerlink" title="package-lock.json文件的作用"></a>package-lock.json文件的作用</h4><ul>
<li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li>
<li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li>
</ul>
<h4 id="Node-js中模块加载机制"><a href="#Node-js中模块加载机制" class="headerlink" title="Node.js中模块加载机制"></a>Node.js中模块加载机制</h4><h5 id="模块查找规则-当模块拥有路径但没有后缀时"><a href="#模块查找规则-当模块拥有路径但没有后缀时" class="headerlink" title="模块查找规则-当模块拥有路径但没有后缀时"></a>模块查找规则-当模块拥有路径但没有后缀时</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./find.js'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./find'</span>);</span><br><span class="line">(<span class="number">1</span>)<span class="built_in">require</span>方法根据模块路径查找模块，如果是完整路径，直接引入模块。</span><br><span class="line">(<span class="number">2</span>)如果模块后缀省略，先找同名JS文件再找同名JS文件夹</span><br><span class="line">(<span class="number">3</span>)如果找到了同名文件夹，找文件夹中的index.js</span><br><span class="line">(<span class="number">4</span>)如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件</span><br><span class="line">(<span class="number">5</span>)如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</span><br></pre></td></tr></table></figure>

<h5 id="模块查找规则-当模块没有路径且没有后缀时"><a href="#模块查找规则-当模块没有路径且没有后缀时" class="headerlink" title="模块查找规则-当模块没有路径且没有后缀时"></a>模块查找规则-当模块没有路径且没有后缀时</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'find'</span>);</span><br><span class="line">(<span class="number">1</span>)Node.js会假设它是系统模块</span><br><span class="line">(<span class="number">2</span>)Node.js会去node_modules文件夹中</span><br><span class="line">(<span class="number">3</span>)首先看是否有该名字的JS文件</span><br><span class="line">(<span class="number">4</span>)再看是否有该名字的文件夹</span><br><span class="line">(<span class="number">5</span>)如果是文件夹看里面是否有index.js</span><br><span class="line">(<span class="number">6</span>)如果没有index.js查看该文件夹中的package.json中的main选项确定模块入口文件</span><br><span class="line">(<span class="number">7</span>)否则找不到报错</span><br></pre></td></tr></table></figure>

<h2 id="Node创建web服务器"><a href="#Node创建web服务器" class="headerlink" title="Node创建web服务器"></a>Node创建web服务器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 引用系统模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"> <span class="comment">// 创建web服务器</span></span><br><span class="line"><span class="keyword">const</span> app = http.createServer();</span><br><span class="line"> <span class="comment">// 当客户端发送请求的时候</span></span><br><span class="line">app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">       <span class="comment">//  响应</span></span><br><span class="line">      res.end(<span class="string">'&lt;h1&gt;hi, user&lt;/h1&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">// 监听3000端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器已启动，监听3000端口，请访问 localhost:3000'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="GET请求参数"><a href="#GET请求参数" class="headerlink" title="GET请求参数"></a>GET请求参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数被放置在浏览器地址栏中，例如：http:<span class="comment">//localhost:3000/?name=zhangsan&amp;age=20</span></span><br><span class="line">参数获取需要借助系统模块url，url模块用来处理url地址</span><br><span class="line"> <span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"> <span class="comment">// 导入url系统模块 用于处理url地址</span></span><br><span class="line"> <span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"> <span class="keyword">const</span> app = http.createServer();</span><br><span class="line"> app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">     <span class="comment">// 将url路径的各个部分解析出来并返回对象</span></span><br><span class="line">         <span class="comment">// true 代表将参数解析为对象格式</span></span><br><span class="line">     <span class="keyword">let</span> &#123;query&#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(query);</span><br><span class="line"> &#125;);</span><br><span class="line"> app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="POST请求参数"><a href="#POST请求参数" class="headerlink" title="POST请求参数"></a>POST请求参数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">参数被放置在请求体中进行传输</span><br><span class="line">获取POST参数需要使用data事件和end事件</span><br><span class="line">使用querystring系统模块将参数转换为对象格式</span><br><span class="line"> <span class="comment">// 导入系统模块querystring 用于将HTTP参数转换为对象格式</span></span><br><span class="line"> <span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"> app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> postData = <span class="string">''</span>;</span><br><span class="line">     <span class="comment">// 监听参数传输事件</span></span><br><span class="line">     req.on(<span class="string">'data'</span>, (chunk) =&gt; postData += chunk;);</span><br><span class="line">     <span class="comment">// 监听参数传输完毕事件</span></span><br><span class="line">     req.on(<span class="string">'end'</span>, () =&gt; &#123; </span><br><span class="line">         <span class="built_in">console</span>.log(querystring.parse(postData)); </span><br><span class="line">     &#125;); </span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/index</span></span><br><span class="line">http:<span class="comment">//localhost:3000/login</span></span><br><span class="line">路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。</span><br><span class="line"> <span class="comment">// 当客户端发来请求的时候</span></span><br><span class="line"> app.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">     <span class="comment">// 获取客户端的请求路径</span></span><br><span class="line">     <span class="keyword">let</span> &#123; pathname &#125; = url.parse(req.url);</span><br><span class="line">     <span class="keyword">if</span> (pathname == <span class="string">'/'</span> || pathname == <span class="string">'/index'</span>) &#123;</span><br><span class="line">         res.end(<span class="string">'欢迎来到首页'</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pathname == <span class="string">'/list'</span>) &#123;</span><br><span class="line">         res.end(<span class="string">'欢迎来到列表页页'</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">'抱歉, 您访问的页面出游了'</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Node-js异步编程"><a href="#Node-js异步编程" class="headerlink" title="Node.js异步编程"></a>Node.js异步编程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="number">1</span>)同步API,异步API</span><br><span class="line"><span class="comment">// 路径拼接</span></span><br><span class="line"> <span class="keyword">const</span> public = path.join(__dirname, <span class="string">'public'</span>);</span><br><span class="line"> <span class="comment">// 请求地址解析</span></span><br><span class="line"> <span class="keyword">const</span> urlObj = url.parse(req.url);</span><br><span class="line"> <span class="comment">// 读取文件</span></span><br><span class="line"> fs.readFile(<span class="string">'./demo.txt'</span>, <span class="string">'utf8'</span>, (err, result) =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(result);</span><br><span class="line"> &#125;);</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">n1, n2</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> n1 + n2;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> result = sum (<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">msg</span>: <span class="string">'Hello Node.js'</span> &#125;</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> msg = getMsg ();</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)同步API：只有当前API执行完成后，才能继续执行下一个API</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line">异步API：当前API的执行不会阻塞后续代码的执行</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">setTimeout(</span><br><span class="line">   () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'last'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">n1, n2</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> n1 + n2;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">const</span> result = sum (<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">msg</span>: <span class="string">'Hello Node.js'</span> &#125;</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> msg = getMsg ();</span><br></pre></td></tr></table></figure>

<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)自己定义函数让别人去调用。  </span><br><span class="line">  <span class="comment">// getData函数定义</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">callback</span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// getData函数调用</span></span><br><span class="line"> getData (<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// 使用回调函数获取异步API执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback (&#123; <span class="attr">msg</span>: <span class="string">'Hello Node.js'</span> &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line">getMsg (<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)同步API, 异步API的区别（代码执行顺序）</span><br><span class="line"><span class="comment">// 同步API从上到下依次执行，前面代码会阻塞后面代码的执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for循环后面的代码'</span>);</span><br><span class="line"><span class="comment">// 异步API不会等待API执行完成后再向下执行代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码开始执行'</span>); </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'2秒后执行的代码'</span>)&#125;, <span class="number">2000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'"0秒"后执行的代码'</span>)&#125;, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码结束执行'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Node-js中的异步API"><a href="#Node-js中的异步API" class="headerlink" title="Node.js中的异步API"></a>Node.js中的异步API</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise出现的目的是解决Node.js异步编程中回调地狱的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let promise = <span class="keyword">new</span> Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            resolve(&#123;name: <span class="string">'张三'</span>&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="string">'失败了'</span>) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(result =&gt; console.log(result); <span class="comment">// &#123;name: '张三'&#125;)</span></span><br><span class="line">       .<span class="keyword">catch</span>(error =&gt; console.log(error); <span class="comment">// 失败了)</span></span><br></pre></td></tr></table></figure>

<h3 id="异步函数async"><a href="#异步函数async" class="headerlink" title="异步函数async"></a>异步函数async</h3><p>异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>关键字</span><br><span class="line"><span class="number">1.</span> 普通函数定义前加<span class="keyword">async</span>关键字 普通函数变成异步函数</span><br><span class="line"><span class="number">2.</span> 异步函数默认返回promise对象</span><br><span class="line"><span class="number">3.</span> 在异步函数内部使用<span class="keyword">return</span>关键字进行结果返回 结果会被包裹的promise对象中 <span class="keyword">return</span>关键字代替了resolve方法</span><br><span class="line"><span class="number">4.</span> 在异步函数内部使用<span class="keyword">throw</span>关键字抛出程序异常</span><br><span class="line"><span class="number">5.</span> 调用异步函数再链式调用then方法获取异步函数执行结果</span><br><span class="line"><span class="number">6.</span> 调用异步函数再链式调用<span class="keyword">catch</span>方法获取异步函数执行的错误信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span>关键字</span><br><span class="line"><span class="number">1.</span> <span class="keyword">await</span>关键字只能出现在异步函数中</span><br><span class="line"><span class="number">2.</span> <span class="keyword">await</span> promise <span class="keyword">await</span>后面只能写promise对象 写其他类型的API是不不可以的</span><br><span class="line"><span class="number">3.</span> <span class="keyword">await</span>关键字可是暂停异步函数向下执行 直到promise返回结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">// 改造现有异步函数api 让其返回promise对象 从而支持异步函数语法</span></span><br><span class="line"><span class="keyword">const</span> promisify = <span class="built_in">require</span>(<span class="string">'util'</span>).promisify;</span><br><span class="line"><span class="comment">// 调用promisify方法改造现有异步API 让其返回promise对象</span></span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> r1 = <span class="keyword">await</span> readFile(<span class="string">'./1.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">	<span class="keyword">let</span> r2 = <span class="keyword">await</span> readFile(<span class="string">'./2.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">	<span class="keyword">let</span> r3 = <span class="keyword">await</span> readFile(<span class="string">'./3.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(r1)</span><br><span class="line">	<span class="built_in">console</span>.log(r2)</span><br><span class="line">	<span class="built_in">console</span>.log(r3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/btcwiki">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/Zhuyokin">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://yokinzhu.blogspot.com/" target="_blank" rel="noopener">本人废弃的博客</a></span>
        <span>/</span>
        
        <span><a href="https://bicuz.com" target="_blank" rel="noopener">区块链导航</a></span>
        <span>/</span>
        
        <span><a href="https://www.re0.cn" target="_blank" rel="noopener">re0</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>

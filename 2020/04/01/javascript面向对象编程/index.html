<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Yokin的博客">
    <meta name="keyword"  content="前端技术分享">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        javascript面向对象编程 - Yokin的博客 | Yokin&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 重剑无锋,大巧不工! </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>Yokin</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#javascript面向对象编程"><span class="toc-text">javascript面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6中的类和对象"><span class="toc-text">ES6中的类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类-class"><span class="toc-text">类 class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承"><span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类里面的this指向问题"><span class="toc-text">类里面的this指向问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数和原型"><span class="toc-text">构造函数和原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数原型prototype"><span class="toc-text">构造函数原型prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象原型-proto"><span class="toc-text">对象原型 __proto__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor构造函数"><span class="toc-text">constructor构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS的成员查找机制"><span class="toc-text">JS的成员查找机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型对象this指向"><span class="toc-text">原型对象this指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展内置对象"><span class="toc-text">扩展内置对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#借用构造函数继承父类属性"><span class="toc-text">借用构造函数继承父类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#借用原型对象继承父类型方法"><span class="toc-text">借用原型对象继承父类型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的本质"><span class="toc-text">类的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6中的新增方法"><span class="toc-text">ES6中的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#"><span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 重剑无锋,大巧不工! </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        javascript面向对象编程
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-04-01 18:02:22</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#面向对象" title="面向对象">面向对象</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="javascript面向对象编程"><a href="#javascript面向对象编程" class="headerlink" title="javascript面向对象编程"></a>javascript面向对象编程</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面向过程编程 POP(Process-oriented programming)</span></span><br><span class="line">面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</span><br><span class="line"><span class="comment">// 面向对象编程 OOP (Object Oriented Programming)</span></span><br><span class="line">在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。</span><br><span class="line">面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</span><br></pre></td></tr></table></figure>

<h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
<p>对象是由属性和方法组成的：</p>
<p>属性：事物的<strong>特征，</strong>在对象中用<strong>属性</strong>来表示（常用名词）</p>
<p>方法：事物的<strong>行为，</strong>在对象中用<strong>方法</strong>来表示（常用动词）</p>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><p>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。</p>
<p>创建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建类 class  创建一个 明星类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类的共有属性放到 constructor 里面</span></span><br><span class="line">    constructor(uname, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    sing(song) &#123;</span><br><span class="line">        <span class="comment">// console.log('我唱歌');</span></span><br><span class="line">		console.log(<span class="keyword">this</span>.uname + song);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 利用类创建对象 new</span></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">'刘德华'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> Star(<span class="string">'张学友'</span>, <span class="number">20</span>);</span><br><span class="line">console.log(ldh);</span><br><span class="line">console.log(zxy);</span><br><span class="line">ldh.sing(<span class="string">'冰雨'</span>);</span><br><span class="line">zxy.sing(<span class="string">'李香兰'</span>);</span><br><span class="line"><span class="comment">//(1) 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</span></span><br><span class="line"><span class="comment">//(2) 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</span></span><br><span class="line"><span class="comment">//(3) constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</span></span><br><span class="line"><span class="comment">//(4) 生成实例 new 不能省略</span></span><br><span class="line"><span class="comment">//(5) 最后注意语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</span></span><br><span class="line"><span class="comment">//(6) 方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。</span></span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类可以继承父类的一些属性和方法。super 关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数.</p>
<p> 注意: 子类在构造函数中使用super, 必须放到 this 前面 (必须先调用父类的构造方法,在使用子类构造方法)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    sum()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x+<span class="keyword">this</span>.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y); <span class="comment">//调用了父类中的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> son1 = <span class="keyword">new</span> Son(<span class="number">11</span>, <span class="number">22</span>);</span><br><span class="line">son.sum();</span><br><span class="line">son1.sum();</span><br><span class="line"><span class="comment">// 继承中的属性或者方法查找原则: 就近原则</span></span><br><span class="line"><span class="comment">// 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的</span></span><br><span class="line"><span class="comment">// 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则)</span></span><br></pre></td></tr></table></figure>

<h3 id="类里面的this指向问题"><a href="#类里面的this指向问题" class="headerlink" title="类里面的this指向问题"></a>类里面的this指向问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        var that;</span></span><br><span class="line"><span class="regexp">        var _that;</span></span><br><span class="line"><span class="regexp">        class Star &#123;</span></span><br><span class="line"><span class="regexp">            constructor(uname, age) &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ constructor 里面的this 指向的是 创建的实例对象</span></span><br><span class="line"><span class="regexp">                that = this;</span></span><br><span class="line"><span class="regexp">                console.log(this);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                this.uname = uname;</span></span><br><span class="line"><span class="regexp">                this.age = age;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ this.sing();</span></span><br><span class="line"><span class="regexp">                this.btn = document.querySelector('button');</span></span><br><span class="line"><span class="regexp">                this.btn.onclick = this.sing;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            sing() &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数</span></span><br><span class="line"><span class="regexp">                console.log(this);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                console.log(that.uname); /</span><span class="regexp">/ that里面存储的是constructor里面的this</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            dance() &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数</span></span><br><span class="line"><span class="regexp">                _that = this;</span></span><br><span class="line"><span class="regexp">                console.log(this);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        var ldh = new Star('刘德华');</span></span><br><span class="line"><span class="regexp">        console.log(that === ldh);</span></span><br><span class="line"><span class="regexp">        ldh.dance();</span></span><br><span class="line"><span class="regexp">        console.log(_that === ldh);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 2. 类里面的共有的属性和方法一定要加this使用.</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h2><p>在典型的 OOP 的语言中（如 Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在 ES6之前， JS 中并没用引入类的概念。</p>
<p>ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>在 ES6之前 ，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p>
<p>创建对象可以通过三种方式： 对象字面量，new Object()， 自定义构造函数</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
<p>在 JS 中，使用构造函数时要注意以下两点：</p>
<p>1.构造函数用于创建某一类对象，其首字母要大写</p>
<p>2.构造函数要和 new 一起使用才有意义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 在执行时会做四件事情：</span><br><span class="line">在内存中创建一个新的空对象。</span><br><span class="line">让 <span class="keyword">this</span> 指向这个新的对象。</span><br><span class="line">执行构造函数里面的代码，给这个新对象添加属性和方法。</span><br><span class="line">返回这个新对象（所以构造函数里面不需要 <span class="keyword">return</span> ）。</span><br><span class="line"></span><br><span class="line">JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 <span class="keyword">this</span> 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问 </span><br><span class="line">实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问</span><br></pre></td></tr></table></figure>

<h3 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h3><p>构造函数方法很好用，但是存在浪费内存的问题。我们希望所有的对象使用同一个函数，这样就比较节省内存，那么我们让构造函数原型来给对象实例共享方法。</p>
<p>构造函数通过原型分配的函数是所有对象所<strong>共享的</strong>。</p>
<p>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p>
<p>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p>
<h3 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 __proto__"></a>对象原型 <code>__proto__</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。</span><br><span class="line">__proto__对象原型和原型对象 prototype 是等价的</span><br><span class="line">__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</span><br></pre></td></tr></table></figure>

<h3 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h3><p>对象原型（ <code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p>
<p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="/2020/04/01/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt></p>
<h3 id="JS的成员查找机制"><a href="#JS的成员查找机制" class="headerlink" title="JS的成员查找机制"></a>JS的成员查找机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</span><br><span class="line">如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</span><br><span class="line">如果还没有就查找原型对象的原型（Object的原型对象）。</span><br><span class="line">依此类推一直找到 Object 为止（<span class="keyword">null</span>）。</span><br><span class="line">__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</span><br></pre></td></tr></table></figure>

<h3 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a>原型对象this指向</h3><p>构造函数中的this 指向我们实例对象.</p>
<p>原型对象里面放的是方法, 这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象.</p>
<h3 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h3><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p>
<p>注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6之前并没有给我们提供 extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call()</span></span><br><span class="line"><span class="comment">// 调用这个函数, 并且修改函数运行时的 this 指向   </span></span><br><span class="line">fun.call(thisArg, arg1, arg2, ...) </span><br><span class="line">thisArg ：当前调用函数 <span class="keyword">this</span> 的指向对象</span><br><span class="line">arg1，arg2：传递的其他参数</span><br></pre></td></tr></table></figure>

<h3 id="借用构造函数继承父类属性"><a href="#借用构造函数继承父类属性" class="headerlink" title="借用构造函数继承父类属性"></a>借用构造函数继承父类属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。   </span></span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">      <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, score</span>) </span>&#123;</span><br><span class="line">      Person.call(<span class="keyword">this</span>, name, age, sex);  <span class="comment">// 此时父类的 this 指向子类的 this，同时调用这个函数</span></span><br><span class="line">      <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'zs'</span>, <span class="number">18</span>, <span class="string">'男'</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(s1);</span><br></pre></td></tr></table></figure>

<h3 id="借用原型对象继承父类型方法"><a href="#借用原型对象继承父类型方法" class="headerlink" title="借用原型对象继承父类型方法"></a>借用原型对象继承父类型方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。  </span><br><span class="line"> 核心原理： </span><br><span class="line">(<span class="number">1</span>)将子类所共享的方法提取出来，让子类的 prototype 原型对象 = <span class="keyword">new</span> 父类()  </span><br><span class="line">(<span class="number">2</span>)本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</span><br><span class="line">(<span class="number">3</span>)将子类的 <span class="keyword">constructor</span> 从新指向子类的构造函数</span><br></pre></td></tr></table></figure>

<h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">class</span>本质还是<span class="title">function</span>.</span></span><br><span class="line"><span class="class">2. 类的所有方法都定义在类的<span class="title">prototype</span>属性上</span></span><br><span class="line"><span class="class">3. 类创建的实例,里面也有<span class="title">__proto__</span> 指向类的<span class="title">prototype</span>原型对象</span></span><br><span class="line"><span class="class">4.所以<span class="title">ES6</span>的类它的绝大部分功能，<span class="title">ES5</span>都可以做到，新的<span class="title">class</span>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</span></span><br><span class="line"><span class="class">5.所以<span class="title">ES6</span>的类其实就是语法糖.</span></span><br><span class="line">6. 语法糖:语法糖就是一种便捷写法.简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖.</span><br></pre></td></tr></table></figure>

<h2 id="ES6中的新增方法"><a href="#ES6中的新增方法" class="headerlink" title="ES6中的新增方法"></a>ES6中的新增方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组方法</span></span><br><span class="line">迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</span><br><span class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>))</span></span><br><span class="line"><span class="function"><span class="title">currentValue</span>：数组当前项的值</span></span><br><span class="line"><span class="function"><span class="title">index</span>：数组当前项的索引</span></span><br><span class="line"><span class="function"><span class="title">arr</span>：数组对象本身</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">filter</span>(<span class="params">function(currentValue, index, arr</span>))</span></span><br><span class="line"><span class="function"><span class="title">filter</span>(<span class="params"></span>) 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组</span></span><br><span class="line"><span class="function">注意它直接返回一个新数组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">array</span>.<span class="title">some</span>(<span class="params">function(currentValue, index, arr</span>))</span></span><br><span class="line"><span class="function"> <span class="title">some</span>(<span class="params"></span>) 方法用于检测数组中的元素是否满足指定条件.通俗点,查找数组中是否有满足条件的元素 </span></span><br><span class="line"><span class="function">注意它返回值是布尔值, 如果查找到这个元素, 就返回<span class="title">true</span>,如果查找不到就返回<span class="title">false</span>.</span></span><br><span class="line"><span class="function">如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 字符串方法</span></span><br><span class="line"><span class="function"><span class="title">trim</span>(<span class="params"></span>)  方法会从一个字符串的两端删除空白字符,但并不能删除字符串中间的空白字符。</span></span><br><span class="line"><span class="function"><span class="title">str</span>.<span class="title">trim</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">trim</span>(<span class="params"></span>) 方法并不影响原字符串本身，它返回的是一个新的字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 对象方法</span></span><br><span class="line"><span class="function">1.  <span class="title">Object</span>.<span class="title">keys</span>(<span class="params"></span>) 用于获取对象自身所有的属性</span></span><br><span class="line"><span class="function"><span class="title">Object</span>.<span class="title">keys</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function">效果类似 <span class="title">for</span>…<span class="title">in</span></span></span><br><span class="line"><span class="function">返回一个由属性名组成的数组</span></span><br><span class="line"><span class="function">2.  <span class="title">Object</span>.<span class="title">defineProperty</span>(<span class="params"></span>) 定义对象中新属性或修改原有的属性。(<span class="params">了解</span>)</span></span><br><span class="line"><span class="function"><span class="title">Object</span>.<span class="title">defineProperty</span>(<span class="params">obj, prop, descriptor</span>)</span></span><br><span class="line"><span class="function"><span class="title">obj</span>：必需。目标对象 </span></span><br><span class="line"><span class="function"><span class="title">prop</span>：必需。需定义或修改的属性的名字</span></span><br><span class="line"><span class="function"><span class="title">descriptor</span>：必需。目标属性所拥有的特性</span></span><br><span class="line"><span class="function"><span class="title">Object</span>.<span class="title">defineProperty</span>(<span class="params"></span>)   第三个参数 <span class="title">descriptor</span> 说明： 以对象形式 </span>&#123; &#125; 书写</span><br><span class="line">value: 设置属性的值  默认为<span class="literal">undefined</span></span><br><span class="line">writable: 值是否可以重写。<span class="literal">true</span> | <span class="literal">false</span>  默认为<span class="literal">false</span></span><br><span class="line">enumerable: 目标属性是否可以被枚举。<span class="literal">true</span> | <span class="literal">false</span> 默认为 <span class="literal">false</span></span><br><span class="line">configurable: 目标属性是否可以被删除或是否可以再次修改特性 <span class="literal">true</span> | <span class="literal">false</span>  默认为<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id><a href="#" class="headerlink" title></a></h5>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/btcwiki">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/Zhuyokin">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://yokinzhu.blogspot.com/" target="_blank" rel="noopener">本人废弃的博客</a></span>
        <span>/</span>
        
        <span><a href="https://bicuz.com" target="_blank" rel="noopener">区块链导航</a></span>
        <span>/</span>
        
        <span><a href="https://www.re0.cn" target="_blank" rel="noopener">re0</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
    </p>
    
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>

[{"title":"CSS Extension Language——Less","url":"/2020/03/30/CSS-Extension-Language——Less/","content":"\n# Less\n\n## Abstract\n\n Less (which stands for Leaner Style Sheets) is a backwards-compatible language extension for CSS. There are a variety of features in Less including Variables,Nesting,Mixins,Functions and so on.Less could improve our efficiency while coding in a front end program and make it easier for us to  maintain our programs. This article would give a quick overview of these features.\n\n## Comments\n\nBoth block-style and inline comments may be used in Less\n\n```less\n/* This is  a block\n * style comment. */\n@var: skyblue;\n\n// This is an inline comment.\n@var: blue;\n```\n\n## Importing\n\nJust like the importing rule of CSS,we can import a `.less` files or  `.css` files in any `.less` files. The extension is optionally optionally soecified for `.less` files.\n\n```less\n@import \"style\"; // style.less\n@important \"main.css\";\n```\n\n## Variables\n\nIn a less file, we can easily use variables. The name of variable starts with @.\n\n```less\n@color:blue;\n@width:30px;\n@height:@width+30px;\n@selector:#wrap;\ndiv {\n    width:@width; // 30px\n    height:@height; // 60px\n}\n@{selector}{      // #wrap\n    width: 300px;  \n    height: 400px;\n}\n```\n\n## Nesting\n\nLess mimics the structure of HTML . It gives you the ability to use nesting instead of only cascading.\n\n```less\n#main {\n    padding:10px;\n    border:1px solid #ccc;\n    .leftBox{\n        color:blue;\n    }\n    .centerBox{\n        color:yellow;\n        &:hover{  \n            background: pink;  \n        }\n    }\n    .rightBox{\n        color:pink;\n    }\n}\n```\n\n outputs :\n\n```css\n#main {\n  padding: 10px;\n  border: 1px solid #ccc;\n}\n#main .leftBox {\n  color: blue;\n}\n#main .centerBox {\n  color: yellow;\n}\n#main .centerBox:hover {\n  background: pink;\n}\n#main .rightBox {\n  color: pink;\n}\n```\n\n### Nested At-Rules and Bubbling\n\n At-rules such as `@media` or `@supports` can be nested in the same way as selectors. The at-rule is placed on top and relative order against other elements inside the same ruleset remains unchanged. This is called bubbling. \n\n```css\n.component {\n  width: 300px;\n  @media (min-width: 768px) {\n    width: 600px;\n    @media  (min-resolution: 192dpi) {\n      background-image: url(/img/retina2x.png);\n    }\n  }\n  @media (min-width: 1280px) {\n    width: 800px;\n  }\n}\n```\n\noutputs:\n\n```css\n.component {\n  width: 300px;\n}\n@media (min-width: 768px) {\n  .component {\n    width: 600px;\n  }\n}\n@media (min-width: 768px) and (min-resolution: 192dpi) {\n  .component {\n    background-image: url(/img/retina2x.png);\n  }\n}\n@media (min-width: 1280px) {\n  .component {\n    width: 800px;\n  }\n}\n```\n\n## Mixins\n\nThis feature provides a method of including a bunch of properties from one rule-set into another rule-set in a `.less` file. We first defined a rule-set . Then,we just have to drop in the name of the css where we want the properties.\n\n```less\n.border {\n    border: 1px solid #ccc;\n    border-radius: 3px;\n}\n#header {\n    width: 300px;\n    height: 300px;\n    .border();\n}\n```\n\noutputs:\n\n```css\n.border {\n  border: 1px solid #ccc;\n  border-radius: 3px;\n}\n#header {\n  width: 300px;\n  height: 300px;\n  border: 1px solid #ccc;\n  border-radius: 3px;\n}\n```\n\n## Operations\n\nArithmetical operation `+ - * /`could operate on any number, color or variable.\n\n```less\n@width:5px + 3;  // 8px\n// numbers are converted into the same units\n@height:2 - 4cm + 5mm; // -1.5cm\n// example with variables\n@fontSizeS:10px;\n@fontSizeM:@fontSizeS * 2; // 20px \n@fontSizeB:@fontSizeS+@fontSizeM; // 30px\n// You can also do arithmetic on colors\n@color1:#111111;\n@color2:#223344+@color1; // #334455\n```\n\n## Escaping\n\n Escaping allows you to use any arbitrary string as property or variable value. Anything inside `~\"anything\"` or `~'anything'` is used as is with no changes except interpolation.\n\n```less\n@min768: ~\"(min-width: 768px)\";\n.element {\n  @media @min768 {\n    font-size: 1.2rem;\n  }\n}\n```\n\noutputs:\n\n```css\n@media (min-width: 768px) {\n  .element {\n    font-size: 1.2rem;\n  }\n}\n```\n\nNotice: as of Less 3.5,you can simply write:\n\n```less\n@min768: (min-width: 768px);\n.element {\n  @media @min768 {\n    font-size: 1.2rem;\n  }\n}\n```\n\n In 3.5+, many cases previously requiring \"quote-escaping\" are not needed. \n\n## Functions\n\n Less provides a variety of functions which transform colors, manipulate strings and do maths. \n\n```less\n@base: #f04615;\n@width: 0.5;\n\n.class {\n  width: percentage(@width); // returns `50%`\n  color: saturate(@base, 5%);\n  background-color: spin(lighten(@base, 25%), 8);\n}\n```\n\n##  Namespaces and Accessors\n\n Sometimes, you may want to group your mixins, for organizational purposes, or just to offer some encapsulation. You can do this pretty intuitively in Less. Say you want to bundle some mixins and variables under `#bundle`, for later reuse or distributing: \n\n```less\n#bundle() {\n    .button {\n      display: block;\n      border: 1px solid black;\n      background-color: grey;\n      &:hover {\n        background-color: white;\n      }\n    }\n    .tab { \n        width: 100px;\n    }\n    .citation { \n        width:101px;\n     }\n  }\n// Now if we want to mixin the .button class in our #header a, we can do:\n  #header a {\n    color: orange;\n    #bundle.button();  // can also be written as #bundle > .button\n  }\n```\n\noutputs:\n\n```css\n#header a {\n  color: orange;\n  display: block;\n  border: 1px solid black;\n  background-color: grey;\n}\n#header a:hover {\n  background-color: white;\n}\n```\n\n## Maps\n\n As of Less 3.5, you can also use mixins and rulesets as maps of values. \n\n```less\n#colors() {\n  primary: blue;\n  secondary: green;\n}\n\n.button {\n  color: #colors[primary];\n  border: 1px solid #colors[secondary];\n}\n```\n\noutputs:\n\n```css\n.button {\n  color: blue;\n  border: 1px solid green;\n}\n```\n\n## Scope\n\n Scope in Less is very similar to that of CSS. Variables and mixins are first looked for locally, and if they aren't found, it's inherited from the \"parent\" scope. \n\n```less\n@var: red;\n\n#page {\n  @var: white;\n  #header {\n    color: @var; // white\n  }\n}\n```\n\noutputs:\n\n```css\n@var: red;\n\n#page {\n  #header {\n    color: @var; // white\n  }\n  @var: white;\n}\n```\n\n","tags":["Less"]},{"title":"计算机基础","url":"/2020/03/29/计算机基础/","content":"\n# 计算机基础\n\n## 1.编程语言\n\n### 1.1 编程\n\n编程语言：是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。\n\n计算机程序：就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。\n\n**注意：**上面所定义的计算机指的是任何能够执行代码的设备，可能是智能手机、ATM机、黑莓PI、服务器等等。\n\n### 1.2 计算机语言\n\n计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介。\n\n计算机语言的种类非常的多，总的来说可以分成机器语言，汇编语言和高级语言三大类。\n\n实际上计算机最终所执行的都是 **机器语言**，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础。\n\n### 1.3 编程语言\n\n可以通过类似于人类语言的 ”语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。\n\n编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。\n\n如今通用的编程语言有两种形式：汇编语言和高级语言。\n\n汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。\n\n高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。\n\n### 1.4 翻译器\n\n高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。\n\n翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。 记住1和 0。 \n\n### 1.5 编程语言和标记语言区别\n\n编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的。\n\n标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。\n\n## 2.计算机基础\n\n### 2.1计算机组成\n\n![计算机组成](F:\\前端\\学习总结\\img\\计算机编程基础.png)\n\n### 2.2数据存储\n\n1.计算机内部使用二进制 0 和 1来表示数据。\n\n2.所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。\n\n3.所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。\n\n4.硬盘、内存都是保存的二进制数据。\n\n### 2.3数据存储单位\n\nbit < byte < kb < GB < TB<.....\n\n位(bit)：  1bit 可以保存一个 0 或者 1 （最小的存储单位）\n\n字节(Byte)：1B = 8b\n\n千字节(KB)：1KB = 1024B\n\n兆字节(MB)：1MB = 1024KB\n\n吉字节(GB): 1GB = 1024MB\n\n太字节(TB): 1TB = 1024GB\n\n### 2.4程序运行\n\n1.打开某个程序时，先从硬盘中把程序的代码加载到内存中\n\n2.CPU执行内存中的代码\n\n注意：之所以要内存的一个重要原因，是因为 cpu 运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械）","tags":["编程"]},{"title":"前端开发接口调用方式","url":"/2020/03/28/前端开发接口调用方式/","content":"\n### 接口调用方式\n\n- 原生ajax\n- 基于jQuery的ajax\n- fetch\n- axios\n\n###  异步\n\n- JavaScript的执行环境是「单线程」\n- 所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程\n- 异步模式可以一起执行**多个任务**\n- JS中常见的异步调用\n  - 定时任务\n  - ajax\n  - 事件函数\n\n\n\n### promise\n\n- 主要解决异步深层嵌套的问题\n- promise 提供了简洁的API  使得异步操作更加容易\n\n```html\n \n  <script type=\"text/javascript\">\n    /*\n     1. Promise基本使用\n           我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：\t\t   resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数\n    */\n\n\n    var p = new Promise(function(resolve, reject){\n      //2. 这里用于实现异步任务  setTimeout\n      setTimeout(function(){\n        var flag = false;\n        if(flag) {\n          //3. 正常情况\n          resolve('hello');\n        }else{\n          //4. 异常情况\n          reject('出错了');\n        }\n      }, 100);\n    });\n    //  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 \n    //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了  \n    p.then(function(data){\n      console.log(data)\n    },function(info){\n      console.log(info)\n    });\n  </script>\n```\n\n###  基于Promise发送Ajax请求\n\n```html\n \n  <script type=\"text/javascript\">\n    /*\n      基于Promise发送Ajax请求\n    */\n    function queryData(url) {\n     #   1.1 创建一个Promise实例\n      var p = new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function(){\n          if(xhr.readyState != 4) return;\n          if(xhr.readyState == 4 && xhr.status == 200) {\n            # 1.2 处理正常的情况\n            resolve(xhr.responseText);\n          }else{\n            # 1.3 处理异常情况\n            reject('服务器错误');\n          }\n        };\n        xhr.open('get', url);\n        xhr.send(null);\n      });\n      return p;\n    }\n\t# 注意：  这里需要开启一个服务 \n    # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了\n    queryData('http://localhost:3000/data')\n      .then(function(data){\n        console.log(data)\n        #  1.4 想要继续链式编程下去 需要 return  \n        return queryData('http://localhost:3000/data1');\n      })\n      .then(function(data){\n        console.log(data);\n        return queryData('http://localhost:3000/data2');\n      })\n      .then(function(data){\n        console.log(data)\n      });\n  </script>\n```\n\n### Promise  基本API\n\n####  实例方法\n\n##### .then()\n\n- 得到异步任务正确的结果\n\n##### .catch()\n\n- 获取异常信息\n\n##### .finally()\n\n- 成功与否都会执行（不是正式标准） \n\n```html\n  \n  <script type=\"text/javascript\">\n    /*\n      Promise常用API-实例方法\n    */\n    // console.dir(Promise);\n    function foo() {\n      return new Promise(function(resolve, reject){\n        setTimeout(function(){\n          // resolve(123);\n          reject('error');\n        }, 100);\n      })\n    }\n    // foo()\n    //   .then(function(data){\n    //     console.log(data)\n    //   })\n    //   .catch(function(data){\n    //     console.log(data)\n    //   })\n    //   .finally(function(){\n    //     console.log('finished')\n    //   });\n\n    // --------------------------\n    // 两种写法是等效的\n    foo()\n      .then(function(data){\n        # 得到异步任务正确的结果\n        console.log(data)\n      },function(data){\n        # 获取异常信息\n        console.log(data)\n      })\n      # 成功与否都会执行（不是正式标准） \n      .finally(function(){\n        console.log('finished')\n      });\n  </script>\n```\n\n#### 静态方法\n\n#####  .all()\n\n- `Promise.all`方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用`Promise.resolve`转换为一个promise)。它的状态由这三个promise实例决定\n\n#####  .race()\n\n- `Promise.race`方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为`fulfilled`或`rejected`），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数\n\n\t\n\n```html\n  <script type=\"text/javascript\">\n    /*\n      Promise常用API-对象方法\n    */\n    // console.dir(Promise)\n    function queryData(url) {\n      return new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function(){\n          if(xhr.readyState != 4) return;\n          if(xhr.readyState == 4 && xhr.status == 200) {\n            // 处理正常的情况\n            resolve(xhr.responseText);\n          }else{\n            // 处理异常情况\n            reject('服务器错误');\n          }\n        };\n        xhr.open('get', url);\n        xhr.send(null);\n      });\n    }\n\n    var p1 = queryData('http://localhost:3000/a1');\n    var p2 = queryData('http://localhost:3000/a2');\n    var p3 = queryData('http://localhost:3000/a3');\n     Promise.all([p1,p2,p3]).then(function(result){\n       //   all 中的参数  [p1,p2,p3]   和 返回的结果一 一对应[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"]\n       console.log(result) //[\"HELLO TOM\", \"HELLO JERRY\", \"HELLO SPIKE\"]\n     })\n    Promise.race([p1,p2,p3]).then(function(result){\n      // 由于p1执行较快，Promise的then()将获得结果'P1'。p2,p3仍在继续执行，但执行结果将被丢弃。\n      console.log(result) // \"HELLO TOM\"\n    })\n  </script>\n```\n\n###  fetch\n\n- Fetch API是新的ajax解决方案 Fetch会返回Promise\n- **fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**。\n- fetch(url, options).then(）\n\n```html\n  <script type=\"text/javascript\">\n    /*\n      Fetch API 基本用法\n      \tfetch(url).then()\n     \t第一个参数请求的路径   Fetch会返回Promise   所以我们可以使用then 拿到请求成功的结果 \n    */\n    fetch('http://localhost:3000/fdata').then(function(data){\n      // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据\n      return data.text();\n    }).then(function(data){\n      //   在这个then里面我们能拿到最终的数据  \n      console.log(data);\n    })\n  </script>\n```\n\n####  fetch API  中的 HTTP  请求\n\n- fetch(url, options).then(）\n- HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT\n  - 默认的是 GET 请求\n  - 需要在 options 对象中 指定对应的 method       method:请求使用的方法 \n  - post 和 普通 请求的时候 需要在options 中 设置  请求头 headers   和  body\n\n```html\n   <script type=\"text/javascript\">\n        /*\n              Fetch API 调用接口传递参数\n        */\n       #1.1 GET参数传递 - 传统URL  通过url  ？ 的形式传参 \n        fetch('http://localhost:3000/books?id=123', {\n            \t# get 请求可以省略不写 默认的是GET \n                method: 'get'\n            })\n            .then(function(data) {\n            \t# 它返回一个Promise实例对象，用于获取后台返回的数据\n                return data.text();\n            }).then(function(data) {\n            \t# 在这个then里面我们能拿到最终的数据  \n                console.log(data)\n            });\n\n      #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关   \n        fetch('http://localhost:3000/books/456', {\n            \t# get 请求可以省略不写 默认的是GET \n                method: 'get'\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       #2.1  DELETE请求方式参数传递      删除id  是  id=789\n        fetch('http://localhost:3000/books/789', {\n                method: 'delete'\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       #3 POST请求传参\n        fetch('http://localhost:3000/books', {\n                method: 'post',\n            \t# 3.1  传递数据 \n                body: 'uname=lisi&pwd=123',\n            \t#  3.2  设置请求头 \n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       # POST请求传参\n        fetch('http://localhost:3000/books', {\n                method: 'post',\n                body: JSON.stringify({\n                    uname: '张三',\n                    pwd: '456'\n                }),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n        # PUT请求传参     修改id 是 123 的 \n        fetch('http://localhost:3000/books/123', {\n                method: 'put',\n                body: JSON.stringify({\n                    uname: '张三',\n                    pwd: '789'\n                }),\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n    </script>\n```\n\n####  fetchAPI 中 响应格式\n\n- 用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如`JSON`，`BLOB`或者`TEXT`等等\n\n```js\n\n    /*\n      Fetch响应结果的数据格式\n    */\n    fetch('http://localhost:3000/json').then(function(data){\n      // return data.json();   //  将获取到的数据使用 json 转换对象\n      return data.text(); //  //  将获取到的数据 转换成字符串 \n    }).then(function(data){\n      // console.log(data.uname)\n      // console.log(typeof data)\n      var obj = JSON.parse(data);\n      console.log(obj.uname,obj.age,obj.gender)\n    })\n\n```\n\n###  axios\n\n- 基于promise用于浏览器和node.js的http客户端\n- 支持浏览器和node.js\n- 支持promise\n- 能拦截请求和响应\n- 自动转换JSON数据\n- 能转换请求和响应数据\n\n#### axios基础用法\n\n- get和 delete请求传递参数\n  - 通过传统的url  以 ? 的形式传递参数\n  -  restful 形式传递参数 \n  - 通过params  形式传递参数 \n- post  和 put  请求传递参数\n  - 通过选项传递参数\n  -  通过 URLSearchParams  传递参数 \n\n```js\n    # 1. 发送get 请求 \n\taxios.get('http://localhost:3000/adata').then(function(ret){ \n      #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面\n      // 注意data属性是固定的用法，用于获取后台的实际数据\n      // console.log(ret.data)\n      console.log(ret)\n    })\n\t# 2.  get 请求传递参数\n    # 2.1  通过传统的url  以 ? 的形式传递参数\n\taxios.get('http://localhost:3000/axios?id=123').then(function(ret){\n      console.log(ret.data)\n    })\n    # 2.2  restful 形式传递参数 \n    axios.get('http://localhost:3000/axios/123').then(function(ret){\n      console.log(ret.data)\n    })\n\t# 2.3  通过params  形式传递参数 \n    axios.get('http://localhost:3000/axios', {\n      params: {\n        id: 789\n      }\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n\t#3 axios delete 请求传参     传参的形式和 get 请求一样\n    axios.delete('http://localhost:3000/axios', {\n      params: {\n        id: 111\n      }\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n\n\t# 4  axios 的 post 请求\n    # 4.1  通过选项传递参数\n    axios.post('http://localhost:3000/axios', {\n      uname: 'lisi',\n      pwd: 123\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n\t# 4.2  通过 URLSearchParams  传递参数 \n    var params = new URLSearchParams();\n    params.append('uname', 'zhangsan');\n    params.append('pwd', '111');\n    axios.post('http://localhost:3000/axios', params).then(function(ret){\n      console.log(ret.data)\n    })\n\n \t#5  axios put 请求传参   和 post 请求一样 \n    axios.put('http://localhost:3000/axios/123', {\n      uname: 'lisi',\n      pwd: 123\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n\n```\n\n#### axios 全局配置\n\n```js\n#  配置公共的请求头 \naxios.defaults.baseURL = 'https://api.example.com';\n#  配置 超时时间\naxios.defaults.timeout = 2500;\n#  配置公共的请求头\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n# 配置公共的 post 的 Content-Type\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\n\n```\n\n####  axios 拦截器\n\n- 请求拦截器\n  - 请求拦截器的作用是在请求发送前进行一些操作\n    - 例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易\n- 响应拦截器\n  - 响应拦截器的作用是在接收到响应后进行一些操作\n    - 例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页\n\n```js\n\t# 1. 请求拦截器 \n\taxios.interceptors.request.use(function(config) {\n      console.log(config.url)\n      # 1.1  任何请求都会经过这一步   在发送请求之前做些什么   \n      config.headers.mytoken = 'nihao';\n      # 1.2  这里一定要return   否则配置不成功  \n      return config;\n    }, function(err){\n       #1.3 对请求错误做点什么    \n      console.log(err)\n    })\n\t#2. 响应拦截器 \n    axios.interceptors.response.use(function(res) {\n      #2.1  在接收响应做些什么  \n      var data = res.data;\n      return data;\n    }, function(err){\n      #2.2 对响应错误做点什么  \n      console.log(err)\n    })\n```\n\n###  async  和 await\n\n- async作为一个关键字放到函数前面\n  - 任何一个`async`函数都会隐式返回一个`promise`\n- `await`关键字只能在使用`async`定义的函数中使用\n  -     await后面可以直接跟一个 Promise实例对象\n  -      await函数不能单独使用\n- **async/await 让异步代码看起来、表现起来更像同步代码**\n\n```js\n \t# 1.  async 基础用法\n    # 1.1 async作为一个关键字放到函数前面\n\tasync function queryData() {\n      # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象\n      var ret = await new Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve('nihao')\n        },1000);\n      })\n      // console.log(ret.data)\n      return ret;\n    }\n\t# 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程\n    queryData().then(function(data){\n      console.log(data)\n    })\n\n\t#2.  async    函数处理多个异步函数\n    axios.defaults.baseURL = 'http://localhost:3000';\n\n    async function queryData() {\n      # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码   \n      \n      var info = await axios.get('async1');\n      #2.2  让异步代码看起来、表现起来更像同步代码\n      var ret = await axios.get('async2?info=' + info.data);\n      return ret.data;\n    }\n\n    queryData().then(function(data){\n      console.log(data)\n    })\n```\n","tags":["Ajax","Promise","fetch","axios","async","await"]},{"title":"Vue组件","url":"/2020/03/28/Vue组件/","content":"\n## Vue组件\n\n### 组件\n\n- 组件 (Component) 是 Vue.js 最强大的功能之一\n- 组件可以扩展 HTML 元素，封装可重用的代\n\n### 组件注册\n\n#### 全局注册\n\n- Vue.component('组件名称', { })     第1个参数是标签名称，第2个参数是一个选项对象\n- **全局组件**注册后，任何**vue实例**都可以用\n\n##### 组件基础用\n\n```html\n<div id=\"example\">\n  <!-- 2、 组件使用 组件名称 是以HTML标签的形式使用  -->  \n  <my-component></my-component>\n</div>\n<script>\n    //   注册组件 \n    // 1、 my-component 就是组件中自定义的标签名\n\tVue.component('my-component', {\n      template: '<div>A custom component!</div>'\n    })\n\n    // 创建根实例\n    new Vue({\n      el: '#example'\n    })\n\n</script>\n```\n\n##### 组件注意事项\n\n- 组件参数的data值必须是函数同时这个函数要求返回一个对象 \n- 组件模板必须是单个根元素\n- 组件模板的内容可以是模板字符串\n\n```html\n  <div id=\"app\">\n     <!-- \n\t\t4、  组件可以重复使用多次 \n\t      因为data中返回的是一个对象所以每个组件中的数据是私有的\n\t\t  即每个实例可以维护一份被返回对象的独立的拷贝   \n\t--> \n    <button-counter></button-counter>\n    <button-counter></button-counter>\n    <button-counter></button-counter>\n      <!-- 8、必须使用短横线的方式使用组件 -->\n     <hello-world></hello-world>\n  </div>\n\n<script type=\"text/javascript\">\n\t//5  如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件，\n    // 7、但是在普通的标签模板中，必须使用短横线的方式使用组件\n     Vue.component('HelloWorld', {\n      data: function(){\n        return {\n          msg: 'HelloWorld'\n        }\n      },\n      template: '<div>{{msg}}</div>'\n    });\n    \n    \n    \n    Vue.component('button-counter', {\n      // 1、组件参数的data值必须是函数 \n      // 同时这个函数要求返回一个对象  \n      data: function(){\n        return {\n          count: 0\n        }\n      },\n      //  2、组件模板必须是单个根元素\n      //  3、组件模板的内容可以是模板字符串  \n      template: `\n        <div>\n          <button @click=\"handle\">点击了{{count}}次</button>\n          <button>测试123</button>\n\t\t\t#  6 在字符串模板中可以使用驼峰的方式使用组件\t\n\t\t   <HelloWorld></HelloWorld>\n        </div>\n      `,\n      methods: {\n        handle: function(){\n          this.count += 2;\n        }\n      }\n    })\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        \n      }\n    });\n  </script>\n```\n\n\n\n#### 局部注册\n\n- 只能在当前注册它的vue实例中使用\n\n```html\n  <div id=\"app\">\n      <my-component></my-component>\n  </div>\n\n\n<script>\n    // 定义组件的模板\n    var Child = {\n      template: '<div>A custom component!</div>'\n    }\n    new Vue({\n      //局部注册组件  \n      components: {\n        // <my-component> 将只在父模板可用  一定要在实例上注册了才能在html文件中使用\n        'my-component': Child\n      }\n    })\n </script>\n```\n\n### Vue 调试工具\n\nvue devtools是chrome的一个浏览器调试插件,下载地址:https://github.com/vuejs/vue-devtools\n\n### Vue组件之间传值\n\n#### 父组件向子组件传值\n\n- 父组件发送的形式是以属性的形式绑定值到子组件身上。\n- 然后子组件用属性props接收\n-  在props中使用驼峰形式，模板中需要使用短横线的形式字符串形式的模板中没有这个限制\n\n```html\n  <div id=\"app\">\n    <div>{{pmsg}}</div>\n     <!--1、menu-item  在 APP中嵌套着 故 menu-item   为  子组件      -->\n     <!-- 给子组件传入一个静态的值 -->\n    <menu-item title='来自父组件的值'></menu-item>\n    <!-- 2、 需要动态的数据的时候 需要属性绑定的形式设置 此时 ptitle  来自父组件data 中的数据 . \n\t\t  传的值可以是数字、对象、数组等等\n\t-->\n    <menu-item :title='ptitle' content='hello'></menu-item>\n  </div>\n\n  <script type=\"text/javascript\">\n    Vue.component('menu-item', {\n      // 3、 子组件用属性props接收父组件传递过来的数据  \n      props: ['title', 'content'],\n      data: function() {\n        return {\n          msg: '子组件本身的数据'\n        }\n      },\n      template: '<div>{{msg + \"----\" + title + \"-----\" + content}}</div>'\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        pmsg: '父组件中内容',\n        ptitle: '动态绑定属性'\n      }\n    });\n  </script>\n```\n\n#### 子组件向父组件传值\n\n- 子组件用`$emit()`触发事件\n- `$emit()`  第一个参数为 自定义的事件名称     第二个参数为需要传递的数据\n- 父组件用v-on 监听子组件的事件\n\n```html\n\n <div id=\"app\">\n    <div :style='{fontSize: fontSize + \"px\"}'>{{pmsg}}</div>\n     <!-- 2 父组件用v-on 监听子组件的事件\n\t\t这里 enlarge-text  是从 $emit 中的第一个参数对应   handle 为对应的事件处理函数\t\n\t-->\t\n    <menu-item :parr='parr' @enlarge-text='handle($event)'></menu-item>\n  </div>\n  <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n  <script type=\"text/javascript\">\n    /*\n      子组件向父组件传值-携带参数\n    */\n    \n    Vue.component('menu-item', {\n      props: ['parr'],\n      template: `\n        <div>\n          <ul>\n            <li :key='index' v-for='(item,index) in parr'>{{item}}</li>\n          </ul>\n\t\t\t###  1、子组件用$emit()触发事件\n\t\t\t### 第一个参数为 自定义的事件名称   第二个参数为需要传递的数据  \n          <button @click='$emit(\"enlarge-text\", 5)'>扩大父组件中字体大小</button>\n          <button @click='$emit(\"enlarge-text\", 10)'>扩大父组件中字体大小</button>\n        </div>\n      `\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        pmsg: '父组件中内容',\n        parr: ['apple','orange','banana'],\n        fontSize: 10\n      },\n      methods: {\n        handle: function(val){\n          // 扩大字体大小\n          this.fontSize += val;\n        }\n      }\n    });\n  </script>\n\n```\n\n#### 兄弟之间的传递\n\n- 兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据   \n  - 提供事件中心    var hub = new Vue()\n- 传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)\n- 接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名\n- 销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据\n\n```html\n <div id=\"app\">\n    <div>父组件</div>\n    <div>\n      <button @click='handle'>销毁事件</button>\n    </div>\n    <test-tom></test-tom>\n    <test-jerry></test-jerry>\n  </div>\n  <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n  <script type=\"text/javascript\">\n    /*\n      兄弟组件之间数据传递\n    */\n    //1、 提供事件中心\n    var hub = new Vue();\n\n    Vue.component('test-tom', {\n      data: function(){\n        return {\n          num: 0\n        }\n      },\n      template: `\n        <div>\n          <div>TOM:{{num}}</div>\n          <div>\n            <button @click='handle'>点击</button>\n          </div>\n        </div>\n      `,\n      methods: {\n        handle: function(){\n          //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n          hub.$emit('jerry-event', 2);\n        }\n      },\n      mounted: function() {\n       // 3、接收数据方，通过mounted(){} 钩子中  触发hub.$on(方法名\n        hub.$on('tom-event', (val) => {\n          this.num += val;\n        });\n      }\n    });\n    Vue.component('test-jerry', {\n      data: function(){\n        return {\n          num: 0\n        }\n      },\n      template: `\n        <div>\n          <div>JERRY:{{num}}</div>\n          <div>\n            <button @click='handle'>点击</button>\n          </div>\n        </div>\n      `,\n      methods: {\n        handle: function(){\n          //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n          hub.$emit('tom-event', 1);\n        }\n      },\n      mounted: function() {\n        // 3、接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名\n        hub.$on('jerry-event', (val) => {\n          this.num += val;\n        });\n      }\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        \n      },\n      methods: {\n        handle: function(){\n          //4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据  \n          hub.$off('tom-event');\n          hub.$off('jerry-event');\n        }\n      }\n    });\n  </script>\n\n```\n\n### 组件插槽\n\n- 组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力\n\n#### 匿名插槽\n\n```html\n\n  <div id=\"app\">\n    <!-- 这里的所有组件标签中嵌套的内容会替换掉slot  如果不传值 则使用 slot 中的默认值  -->  \n    <alert-box>有bug发生</alert-box>\n    <alert-box>有一个警告</alert-box>\n    <alert-box></alert-box>\n  </div>\n\n  <script type=\"text/javascript\">\n    /*\n      组件插槽：父组件向子组件传递内容\n    */\n    Vue.component('alert-box', {\n      template: `\n        <div>\n          <strong>ERROR:</strong>\n\t\t# 当组件渲染的时候，这个 <slot> 元素将会被替换为“组件标签中嵌套的内容”。\n\t\t# 插槽内可以包含任何模板代码，包括 HTML\n          <slot>默认内容</slot>\n        </div>\n      `\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        \n      }\n    });\n  </script>\n</body>\n</html>\n\n```\n\n#### 具名插槽\n\n- 具有名字的插槽 \n- 使用 <slot> 中的 \"name\" 属性绑定元素\n\n```HTML\n\n  <div id=\"app\">\n    <base-layout>\n       <!-- 2、 通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上\n\t\t\t\t如果没有匹配到 则放到匿名的插槽中   --> \n      <p slot='header'>标题信息</p>\n      <p>主要内容1</p>\n      <p>主要内容2</p>\n      <p slot='footer'>底部信息信息</p>\n    </base-layout>\n\n    <base-layout>\n      <!-- 注意点：template临时的包裹标签最终不会渲染到页面上     -->  \n      <template slot='header'>\n        <p>标题信息1</p>\n        <p>标题信息2</p>\n      </template>\n      <p>主要内容1</p>\n      <p>主要内容2</p>\n      <template slot='footer'>\n        <p>底部信息信息1</p>\n        <p>底部信息信息2</p>\n      </template>\n    </base-layout>\n  </div>\n  <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n  <script type=\"text/javascript\">\n    /*\n      具名插槽\n    */\n    Vue.component('base-layout', {\n      template: `\n        <div>\n          <header>\n\t\t\t###\t1、 使用 <slot> 中的 \"name\" 属性绑定元素 指定当前插槽的名字\n            <slot name='header'></slot>\n          </header>\n          <main>\n            <slot></slot>\n          </main>\n          <footer>\n\t\t\t###  注意点： \n\t\t\t###  具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序\n            <slot name='footer'></slot>\n          </footer>\n        </div>\n      `\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        \n      }\n    });\n  </script>\n</body>\n</html>\n\n```\n\n####  作用域插槽\n\n- 父组件对子组件加工处理\n- 既可以复用子组件的slot，又可以使slot内容不一致\n\n```html\n  <div id=\"app\">\n    <!-- \n\t\t1、当我们希望li 的样式由外部使用组件的地方定义，因为可能有多种地方要使用该组件，\n\t\t但样式希望不一样 这个时候我们需要使用作用域插槽 \n\t\t\n\t-->  \n    <fruit-list :list='list'>\n       <!-- 2、 父组件中使用了<template>元素,而且包含scope=\"slotProps\",\n\t\t\tslotProps在这里只是临时变量   \n\t\t---> \t\n      <template slot-scope='slotProps'>\n        <strong v-if='slotProps.info.id==3' class=\"current\">\n            {{slotProps.info.name}}\t\t         \n         </strong>\n        <span v-else>{{slotProps.info.name}}</span>\n      </template>\n    </fruit-list>\n  </div>\n  <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n  <script type=\"text/javascript\">\n    /*\n      作用域插槽\n    */\n    Vue.component('fruit-list', {\n      props: ['list'],\n      template: `\n        <div>\n          <li :key='item.id' v-for='item in list'>\n\t\t\t###  3、 在子组件模板中,<slot>元素上有一个类似props传递数据给组件的写法msg=\"xxx\",\n\t\t\t###   插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。\n\t\t\t\t\t如果父组件为这个插槽提供了内容，则默认的内容会被替换掉\n            <slot :info='item'>{{item.name}}</slot>\n          </li>\n        </div>\n      `\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        list: [{\n          id: 1,\n          name: 'apple'\n        },{\n          id: 2,\n          name: 'orange'\n        },{\n          id: 3,\n          name: 'banana'\n        }]\n      }\n    });\n  </script>\n</body>\n</html>\n\n```","tags":["Vue"]},{"title":"Vue常用特性","url":"/2020/03/28/Vue常用特性/","content":"## Vue常用特性\n\n### 表单基本操作\n\n- 获取单选框中的值\n\n  - 通过v-model\n\n  ```html\n   \t<!-- \n  \t\t1、 两个单选框需要同时通过v-model 双向绑定 一个值 \n          2、 每一个单选框必须要有value属性  且value 值不能一样 \n  \t\t3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n  \n  \t\tgender 的值就是选中的值，我们只需要实时监控他的值就可以了\n  \t-->\n     <input type=\"radio\" id=\"male\" value=\"1\" v-model='gender'>\n     <label for=\"male\">男</label>\n  \n     <input type=\"radio\" id=\"female\" value=\"2\" v-model='gender'>\n     <label for=\"female\">女</label>\n  \n  <script>\n      new Vue({\n           data: {\n               // 默认会让当前的 value 值为 2 的单选框选中\n                  gender: 2,  \n              },\n      })\n  \n  </script>\n  ```\n\n- 获取复选框中的值\n\n  - 通过v-model\n  - 和获取单选框中的值一样 \n  - 复选框 `checkbox` 这种的组合时   data 中的 hobby 我们要定义成数组 否则无法实现多选\n\n  ```html\n  \t<!-- \n  \t\t1、 复选框需要同时通过v-model 双向绑定 一个值 \n          2、 每一个复选框必须要有value属性  且value 值不能一样 \n  \t\t3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n  \n  \t\thobby 的值就是选中的值，我们只需要实时监控他的值就可以了\n  \t-->\n  \n  <div>\n     <span>爱好：</span>\n     <input type=\"checkbox\" id=\"ball\" value=\"1\" v-model='hobby'>\n     <label for=\"ball\">篮球</label>\n     <input type=\"checkbox\" id=\"sing\" value=\"2\" v-model='hobby'>\n     <label for=\"sing\">唱歌</label>\n     <input type=\"checkbox\" id=\"code\" value=\"3\" v-model='hobby'>\n     <label for=\"code\">写代码</label>\n   </div>\n  <script>\n      new Vue({\n           data: {\n                  // 默认会让当前的 value 值为 2 和 3 的复选框选中\n                  hobby: ['2', '3'],\n              },\n      })\n  </script>\n  ```\n\n- 获取下拉框和文本框中的值\n\n  - 通过v-model\n\n  ```html\n     <div>\n        <span>职业：</span>\n         <!--\n  \t\t\t1、 需要给select  通过v-model 双向绑定 一个值 \n              2、 每一个option  必须要有value属性  且value 值不能一样 \n  \t\t    3、 当某一个option选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n  \t\t     occupation 的值就是选中的值，我们只需要实时监控他的值就可以了\n  \t\t-->\n         <!-- multiple  多选 -->\n        <select v-model='occupation' multiple>\n            <option value=\"0\">请选择职业...</option>\n            <option value=\"1\">教师</option>\n            <option value=\"2\">软件工程师</option>\n            <option value=\"3\">律师</option>\n        </select>\n           <!-- textarea 是 一个双标签   不需要绑定value 属性的  -->\n          <textarea v-model='desc'></textarea>\n    </div>\n  <script>\n      new Vue({\n           data: {\n                  // 默认会让当前的 value 值为 2 和 3 的下拉框选中\n                   occupation: ['2', '3'],\n               \t desc: 'nihao'\n              },\n      })\n  </script>\n  ```\n\n### 表单修饰符\n\n- .number  转换为数值\n\n  - 注意点：\t\n  - 当开始输入非数字的字符串时，因为Vue无法将字符串转换成数值\n  - 所以属性值将实时更新成相同的字符串。即使后面输入数字，也将被视作字符串。\n\n- .trim  自动过滤用户输入的首尾空白字符\n\n  - 只能去掉首尾的 不能去除中间的空格\n\n- .lazy   将input事件切换成change事件\n\n  - .lazy 修饰符延迟了同步更新属性值的时机。即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上\n\n- 在失去焦点 或者 按下回车键时才更新\n\n  ```html\n  <!-- 自动将用户的输入值转为数值类型 -->\n  <input v-model.number=\"age\" type=\"number\">\n  \n  <!--自动过滤用户输入的首尾空白字符   -->\n  <input v-model.trim=\"msg\">\n  \n  <!-- 在“change”时而非“input”时更新 -->\n  <input v-model.lazy=\"msg\" >\n  ```\n\n###  自定义指令\n\n- 内置指令不能满足我们特殊的需求\n- Vue允许我们自定义指令\n\n#### Vue.directive  注册全局指令\n\n```html\n<!-- \n  使用自定义的指令，只需在对用的元素中，加上'v-'的前缀形成类似于内部指令'v-if'，'v-text'的形式。 \n-->\n<input type=\"text\" v-focus>\n<script>\n// 注意点： \n//   1、 在自定义指令中  如果以驼峰命名的方式定义 如  Vue.directive('focusA',function(){}) \n//   2、 在HTML中使用的时候 只能通过 v-focus-a 来使用 \n    \n// 注册一个全局自定义指令 v-focus\nVue.directive('focus', {\n  \t// 当绑定元素插入到 DOM 中。 其中 el为dom元素\n  \tinserted: function (el) {\n    \t\t// 聚焦元素\n    \t\tel.focus();\n \t}\n});\nnew Vue({\n　　el:'#app'\n});\n</script>\n```\n\n#### Vue.directive  注册全局指令 带参数\n\n```html\n  <input type=\"text\" v-color='msg'>\n <script type=\"text/javascript\">\n    /*\n      自定义指令-带参数\n      bind - 只调用一次，在指令第一次绑定到元素上时候调用\n\n    */\n    Vue.directive('color', {\n      // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\n      // el 为当前自定义指令的DOM元素  \n      // binding 为自定义的函数形参   通过自定义属性传递过来的值 存在 binding.value 里面\n      bind: function(el, binding){\n        // 根据指令的参数设置背景色\n        // console.log(binding.value.color)\n        el.style.backgroundColor = binding.value.color;\n      }\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: {\n          color: 'blue'\n        }\n      }\n    });\n  </script>\n```\n\n#### 自定义指令局部指令\n\n- 局部指令，需要定义在  directives 的选项   用法和全局用法一样 \n- 局部指令只能在当前组件里面使用\n- 当全局指令和局部指令同名时以局部指令为准\n\n```html\n<input type=\"text\" v-color='msg'>\n <input type=\"text\" v-focus>\n <script type=\"text/javascript\">\n    /*\n      自定义指令-局部指令\n    */\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: {\n          color: 'red'\n        }\n      },\n   \t  //局部指令，需要定义在  directives 的选项\n      directives: {\n        color: {\n          bind: function(el, binding){\n            el.style.backgroundColor = binding.value.color;\n          }\n        },\n        focus: {\n          inserted: function(el) {\n            el.focus();\n          }\n        }\n      }\n    });\n  </script>\n```\n\n###  计算属性   computed\n\n- 模板中放入太多的逻辑会让模板过重且难以维护  使用计算属性可以让模板更加的简洁\n- **计算属性是基于它们的响应式依赖进行缓存的**\n- computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化\n\n```html\n <div id=\"app\">\n     <!--  \n        当多次调用 reverseString  的时候 \n        只要里面的 num 值不改变 他会把第一次计算的结果直接返回\n\t\t直到data 中的num值改变 计算属性才会重新发生计算\n     -->\n    <div>{{reverseString}}</div>\n    <div>{{reverseString}}</div>\n     <!-- 调用methods中的方法的时候  他每次会重新调用 -->\n    <div>{{reverseMessage()}}</div>\n    <div>{{reverseMessage()}}</div>\n  </div>\n  <script type=\"text/javascript\">\n    /*\n      计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存\n    */\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: 'Nihao',\n        num: 100\n      },\n      methods: {\n        reverseMessage: function(){\n          console.log('methods')\n          return this.msg.split('').reverse().join('');\n        }\n      },\n      //computed  属性 定义 和 data 已经 methods 平级 \n      computed: {\n        //  reverseString   这个是我们自己定义的名字 \n        reverseString: function(){\n          console.log('computed')\n          var total = 0;\n          //  当data 中的 num 的值改变的时候  reverseString  会自动发生计算  \n          for(var i=0;i<=this.num;i++){\n            total += i;\n          }\n          // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果    \n          return total;\n        }\n      }\n    });\n  </script>\n```\n\n###  侦听器   watch\n\n- 使用watch来响应数据的变化\n- 一般用于异步或者开销较大的操作\n- watch 中的属性 一定是data 中 已经存在的数据 \n- **当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听**\n\n```html\n <div id=\"app\">\n        <div>\n            <span>名：</span>\n            <span>\n        <input type=\"text\" v-model='firstName'>\n      </span>\n        </div>\n        <div>\n            <span>姓：</span>\n            <span>\n        <input type=\"text\" v-model='lastName'>\n      </span>\n        </div>\n        <div>{{fullName}}</div>\n    </div>\n\n  <script type=\"text/javascript\">\n        /*\n              侦听器\n            */\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                firstName: 'Jim',\n                lastName: 'Green',\n                // fullName: 'Jim Green'\n            },\n             //watch  属性 定义 和 data 已经 methods 平级 \n            watch: {\n                //   注意：  这里firstName  对应着data 中的 firstName \n                //   当 firstName 值 改变的时候  会自动触发 watch\n                firstName: function(val) {\n                    this.fullName = val + ' ' + this.lastName;\n                },\n                //   注意：  这里 lastName 对应着data 中的 lastName \n                lastName: function(val) {\n                    this.fullName = this.firstName + ' ' + val;\n                }\n            }\n        });\n    </script>\n```\n\n\n\n###  过滤器\n\n- Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。\n- 过滤器可以用在两个地方：双花括号插值和v-bind表达式。\n- 过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示\n- 支持级联操作\n- 过滤器不改变真正的`data`，而只是改变渲染的结果，并返回过滤后的版本\n- 全局注册时是filter，没有s的。而局部过滤器是filters，是有s的\n\n```html\n  <div id=\"app\">\n    <input type=\"text\" v-model='msg'>\n      <!-- upper 被定义为接收单个参数的过滤器函数，表达式  msg  的值将作为参数传入到函数中 -->\n    <div>{{msg | upper}}</div>\n    <!--  \n      支持级联操作\n      upper  被定义为接收单个参数的过滤器函数，表达式msg 的值将作为参数传入到函数中。\n\t  然后继续调用同样被定义为接收单个参数的过滤器 lower ，将upper 的结果传递到lower中\n \t-->\n    <div>{{msg | upper | lower}}</div>\n    <div :abc='msg | upper'>测试数据</div>\n  </div>\n\n<script type=\"text/javascript\">\n   //  lower  为全局过滤器     \n   Vue.filter('lower', function(val) {\n      return val.charAt(0).toLowerCase() + val.slice(1);\n    });\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: ''\n      },\n       //filters  属性 定义 和 data 以及 methods 平级 \n       //  定义filters 中的过滤器为局部过滤器 \n      filters: {\n        //   upper  自定义的过滤器名字 \n        //    upper 被定义为接收单个参数的过滤器函数，表达式  msg  的值将作为参数传入到函数中\n        upper: function(val) {\n         //  过滤器中一定要有返回值 这样外界使用过滤器的时候才能拿到结果\n          return val.charAt(0).toUpperCase() + val.slice(1);\n        }\n      }\n    });\n  </script>\n```\n\n####  过滤器中传递参数\n\n```html\n    <div id=\"box\">\n        <!--\n\t\t\tfilterA 被定义为接收三个参数的过滤器函数。\n  \t\t\t其中 message 的值作为第一个参数，\n\t\t\t普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。\n\t\t-->\n        {{ message | filterA('arg1', 'arg2') }}\n    </div>\n    <script>\n        // 在过滤器中 第一个参数 对应的是  管道符前面的数据   n  此时对应 message\n        // 第2个参数  a 对应 实参  arg1 字符串\n        // 第3个参数  b 对应 实参  arg2 字符串\n        Vue.filter('filterA',function(n,a,b){\n            if(n<10){\n                return n+a;\n            }else{\n                return n+b;\n            }\n        });\n        \n        new Vue({\n            el:\"#box\",\n            data:{\n                message: \"哈哈哈\"\n            }\n        })\n\n    </script>\n```\n\n\n\n\n\n### 生命周期\n\n- 事物从出生到死亡的过程\n- Vue实例从创建到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数\n\n#### 常用的 钩子函数\n\n| beforeCreate  | 在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化   什么都做不了 |\n| ------------- | ------------------------------------------------------------ |\n| created       | 在实例创建完成后被立即调用此时data 和 methods已经可以使用  但是页面还没有渲染出来 |\n| beforeMount   | 在挂载开始之前被调用   此时页面上还看不到真实数据 只是一个模板页面而已 |\n| mounted       | el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。  数据已经真实渲染到页面上  在这个钩子函数里面我们可以使用一些第三方的插件 |\n| beforeUpdate  | 数据更新时调用，发生在虚拟DOM打补丁之前。   页面上数据还是旧的 |\n| updated       | 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的 |\n| beforeDestroy | 实例销毁之前调用                                             |\n| destroyed     | 实例销毁后调用                                               |\n\n### 数组变异方法\n\n- 在 Vue 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变\n- 变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展\n\n| `push()`    | 往数组最后面添加一个元素，成功返回当前数组的长度             |\n| ----------- | ------------------------------------------------------------ |\n| `pop()`     | 删除数组的最后一个元素，成功返回删除元素的值                 |\n| `shift()`   | 删除数组的第一个元素，成功返回删除元素的值                   |\n| `unshift()` | 往数组最前面添加一个元素，成功返回当前数组的长度             |\n| `splice()`  | 有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除 后想要在原位置替换的值 |\n| `sort()`    | sort()  使数组按照字符编码默认从小到大排序,成功返回排序后的数组 |\n| `reverse()` | reverse()  将数组倒序，成功返回倒序后的数组                  |\n\n### 替换数组\n\n- 不会改变原始数组，但总是返回一个新数组\n\n| filter | filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 |\n| ------ | ------------------------------------------------------------ |\n| concat | concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组 |\n| slice  | slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组 |\n\n### 动态数组响应式数据\n\n- Vue.set(a,b,c)    让 触发视图重新更新一遍，数据动态起来\n- a是要更改的数据 、   b是数据的第几项、   c是更改后的数据\n\n","tags":["Vue"]},{"title":"移动端开发布局","url":"/2020/03/27/移动端开发布局/","content":"\n# 移动端开发布局\n\n## 摘要\n\n在项目开发的技术选型的时候，其中一项就是移动端布局的方案,可提供的方案有流式布局,响应式布局,flex和rem（主流），本文将对上述主流的移动端布局的技术要点进行讲解。\n\n## 流式布局\n\n流式布局,就是百分比布局,也称非固定像素布局。\n\n原理:通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。\n\n流式布局方式式移动web开发使用的比较常见的布局方式.\n\n参数:\n\nmax-width 最大宽度 (max-height 最大高度)\n\nmin-width 最小宽度 (min-height 最小高度)\n\n```html\n// 用法示例\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n        \n        section {\n            width: 100%;\n            max-width: 980px;\n            min-width: 320px;\n            margin: 0 auto;\n        }\n        \n        section div {\n            width: 50%;\n            height: 400px;\n            float: left;\n        }\n        \n        section div:nth-child(1) {\n            background-color: pink;\n        }\n        \n        section div:nth-child(2) {\n            background-color: purple;\n        }\n    </style>\n</head>\n<body>\n    <section>\n        <div></div>\n        <div></div>\n    </section>\n</body>\n\n</html>\n```\n\n## 响应式布局\n\n### 响应式布局原理\n\n就是使用媒体查询针对不同宽度的设备进行布局和样式的设置,从而适配不同设备的目的。\n\n| 设备划分               | 尺寸区间        |\n| ---------------------- | --------------- |\n| 超小屏幕(手机)         | <768px          |\n| 小屏设备(平板)         | >=768px~<992px  |\n| 中等屏幕(桌面显示器)   | >=992px~<1200px |\n| 宽屏设备(大桌面显示器) | >=1200px        |\n\n### 响应式布局容器\n\n 响应式需要一个父级作为布局容器，来配合子级元素来实现变化效果。原理就是在不同屏幕下，通过媒体查询来改变布局容器的大小，再改变里面的子元素的排列方式和大小，从而实现在不同屏幕下，看到不同的页面布局和样式变化。\n\n平时我们的响应式尺寸划分\n\n(1)超小屏幕(手机，小于768px):设置宽度为100%;\n\t\t(2)小屏幕(平板，大于等于768px):设置宽度为750px;\n\t\t(3)中等屏幕(桌面显示器，大于等于992px):设置宽度为970px;\n\t\t(4)大屏幕(大桌面显示器，大于等于1200px):设置宽度为1170px;\n\n ```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>响应式布局原理</title>\n</head>\n<style>\n    .container {\n        height: 150px;\n        background: pink;\n        margin: 0 auto;\n    }\n    /* 1.超小屏幕下，小于768，布局容器宽度100% */\n    \n    @media screen and (max-width:767px) {\n        .container {\n            width: 100%;\n        }\n    }\n    /* 2.小屏幕下，>=768,布局容器改为750px */\n    \n    @media screen and (max-width: 768px) {\n        .container {\n            width: 750px;\n        }\n    }\n    /* 3.中等屏幕下，>=992，布局容器改为970px */\n    \n    @media screen and (max-width: 992px) {\n        .container {\n            width: 970px;\n        }\n    }\n    /* 4.大屏幕下,>=1200,布局容易修改为1170px */\n    \n    @media screen and (max-width: 1200px) {\n        .container {\n            width: 1170px;\n        }\n    }\n</style>\n<body>\n    <!-- 响应式开发里面,首先需要一个布局容器     -->\n    <div class=\"container\"></div>\n</body>\n</html>\n ```\n\n### 媒体查询\n\n####  媒体查询概念\n\n\t\t媒体查询(Media Query)是CSS3新语法.使用@media查询,可以针对不同的媒体类型定义不同的样式\n\t\t@media可以针对不同的屏幕尺寸设置不同的样式\n\t\t当你重置浏览器大小的过程中,页面也会根据浏览器的宽度和高度重新渲染页面\n\t\t目前针对很多苹果手机、Android手机,平板等设备都用得到媒体查询\n\n语法规范\n\n`@media mediatype and|not|only{media feature}{CSS-Code;}`\n\n+ 媒体查询用@media开头\n\n+ mediatype是媒体类型\n\n+ 关键字and not only\n\n+ media feature 媒体特性,必须有小括号包含\n\n#### mediatype媒体查询类型\n\n将不同的终端设备划分成不同的类型,称为媒体查询\n\n| 值     | 解释说明                           |\n| ------ | ---------------------------------- |\n| all    | 用于所有设备                       |\n| print  | 用于打印机和打印预览               |\n| screen | 用于电脑屏幕，平板电脑，智能手机等 |\n\n#### 关键字\n\n关键字将媒体类型或多个媒体特效链接到一起作为媒体查询的条件\n\n+ and:可以将多个媒体特性连接到一起,相当于'且'的意思。\n\n+ not:排除某个媒体类型，相当于'非'的意思，可以忽略。\n\n+ only：指定某个特效的媒体类型,可以省略\n\n#### 媒体特效\n\n每种媒体类型都具有各种不同的特性，根据不同的媒体类型特性设置不同的展示风格。我们战且了解三个。\n\n| 值        | 解释说明                           |\n| --------- | ---------------------------------- |\n| width     | 定义输出设备中页面可见区域的宽度   |\n| min-width | 定义输出设备中页面最小可见区域宽度 |\n| max-width | 定义输出设备中页面最大可见区域宽度 |\n\n代码示例:\n\n```html\n    <style>\n        /* 1. 媒体查询一般按照从大到小或者 从小到大的顺序来 */\n        /* 2. 小于540px 页面的背景颜色变为蓝色 */\n        \n        @media screen and (max-width: 539px) {\n            body {\n                background-color: blue;\n            }\n        }\n        /* 3. 540 ~ 970 我们的页面颜色改为 绿色 */\n        /* @media screen and (min-width: 540px) and (max-width: 969px) {\n            body {\n                background-color: green;\n            }\n        } */\n        \n        @media screen and (min-width: 540px) {\n            body {\n                background-color: green;\n            }\n        }\n        /* 4. 大于等于970 我们页面的颜色改为 红色 */\n        \n        @media screen and (min-width: 970px) {\n            body {\n                background-color: red;\n            }\n        }\n        /* 5. screen 还有 and 必须带上不能省略的 */\n        /* 6. 我们的数字后面必须跟单位  970px   这个 px 不能省略的 */\n    </style>\n```\n\n#### 引入资源\n\n媒体查询支持响应式引入资源文件,当样式比较繁多的时候，我们可以针对不同的媒体使用不同的stylesheets（样式表）。原理，就是直接在link中判断设备的尺寸,然后引入不同的css文件。\n\n```html\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        /* 当我们屏幕大于等于 640px以上的，我们让div 一行显示2个 */\n        /* 当我们屏幕小于640 我们让div一行显示一个 */\n        /* 一个建议： 我们媒体查询最好的方法是从小到大 */\n        /* 引入资源就是 针对于不同的屏幕尺寸 调用不同的css文件 */\n    </style>\n    <link rel=\"stylesheet\" href=\"style320.css\" media=\"screen and (min-width: 320px)\">\n    <link rel=\"stylesheet\" href=\"style640.css\" media=\"screen and (min-width: 640px)\">\n</head>\n```\n\n\n\n## flex布局\n\n1.1传统布局与flex弹性布局\n\n| 传统布局                      | flex弹性布局                           |\n| ----------------------------- | -------------------------------------- |\n| 兼容性好                      | 操作方便,布局极为简单,移动端应用很广泛 |\n| 布局繁琐                      | PC端浏览器支持情况较差                 |\n| 局限性,不能再移动端很好的布局 | IE11或更低版本,不支持或仅部分支持      |\n\n建议:\n\n1.如果是PC端页面布局,我们还是传统布局\n\n2.如果是移动端或不考虑兼容性问题的PC端页面布局,我们还是使用flex弹性布局\n\n### flex布局原理\n\n flex是flexible Box的缩写,意为\"弹性布局\",又称为伸缩布局,伸缩盒布局和flex布局,用来为盒状模型提供最大的灵活性,任何一个容器无论是行内元素还是块级元素都可以指定为flex布局.\n\n当我们为父盒子设为flex布局以后,子元素的float、clear和vertical属性都将失效。\n\n### flex布局父项常见属性\n\n#### 常见的父项属性\n\n 以下6个属性是对父元素设置的\n\t\t*flex-direction:设置主轴的方向\n\t\t*justify-content:设置主轴上的子元素排列方式\n\t\t*flex-wrap:设置子元素是否换行\n\t\t*align-content:设置侧轴上的子元素排列方式（多行）\n\t\t*align-items:设置侧轴上的子元素排列方式（单行）\n\t\t*flex-flow:复合属性,相当于同时设置了flex-direction和flex-wrap\n\n#### flex-**direction**\n\n##### (1)主轴和侧轴\n\n在flex布局中,分为主轴和侧轴两个方向,同样的叫法有:行和列,x轴和y轴\n\n*默认主轴方向就是x轴方向,水平向右\n\n*默认侧轴方向就是y轴方向,水平向下\n\n##### (2)属性值\n\nflex-direction属性决定主轴方向(即项目的排列方向)\n\n注意:主轴和侧轴是会变化的,就看flex-direction设置谁为主轴,剩下的就是侧轴,而我们的子元素是跟着主轴来排列的.\n\n| 属性值         | 说明         |\n| -------------- | ------------ |\n| row            | 默认从左到右 |\n| row-reverse    | 从右到左     |\n| column         | 从上到下     |\n| column-reverse | 从下到上     |\n\n#### justify-content\n\njustify-content设置主轴上的子元素排列方式\n\njustify-content属性定义了项目在主轴上的对齐方式\n\n注意:使用这个属性之前一定要确定好主轴是row还是column\n\n| 属性值        | 说明                                      |\n| ------------- | ----------------------------------------- |\n| flex-start    | 默认值从头部开始,如果主轴是x轴,则从左到右 |\n| flex-end      | 从尾部开始排列                            |\n| center        | 在主轴居中对齐(如果主轴是x轴则水平居中)   |\n| space-around  | 平分剩余空间                              |\n| space-between | 先两边贴边,在评分剩余空间(重要)           |\n\n#### flex-wrap\n\nflex-wrap设置子元素是否换行\n\n 默认情况下,项目都在一条线上(又称为\"轴线\")上。flex-wrap属性定义是否换行,flex布局中默认是不换行的. \n\n| 属性值 | 说明          |\n| ------ | ------------- |\n| nowrap | 默认值,不换行 |\n| wrap   | 换行          |\n\n#### align-items\n\nalign-items设置侧轴上的子元素排列方式(单行)\n\n该属性是控制子项(默认是y轴)上的排列方式,在子项为单行时使用.\n\n| 属性值     | 说明               |\n| ---------- | ------------------ |\n| flex-start | 从上到下           |\n| flex-end   | 从下到上           |\n| center     | 挤在一起(垂直居中) |\n| stretch    | 拉伸(默认值)       |\n\n#### align-content\n\nalign-content设置侧轴上的子元素排列方式(多行)\n\n设置子项在侧轴上的排列方式,并且只能用在子项出现换行的情况下,在单行下是没有效果的!\n\n| 属性值        | 说明                                  |\n| ------------- | ------------------------------------- |\n| flex-start    | 默认值在侧轴的头部开始排列            |\n| flex-end      | 在侧轴的尾部开始排列                  |\n| center        | 在侧轴中间显示                        |\n| space-around  | 子项在侧轴平分剩余空间                |\n| space-between | 子项在侧轴先分布在两头,再评分剩余空间 |\n| stretch       | 设置子项元素宽度平分父级元素高度      |\n\n####   **align-content和align-items的区别** \n\n *align-items适用于单行的情况下,只有上对齐，下对齐、居中和拉伸。\n*align-content适用于多行(换行)的情况下(单行情况下无效)，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性。\n\n *总结就是单行找align-items，多行找align-content。 \n\nflex-flow\n\nflex-flow属性是flex-wrap和flex-direction属性的复合属性.\n\n`flex-flow:row wrap `\n\n### flex布局子项常见属性\n\n#### flex子项占的份数\n\n flex属性定义子项目分配剩余空间,用flex来表示占多少份数。\n\n#### align-self\n\nalign-self控制子项自己再侧轴的排列方式\n\n align-self属性允许单个项目有与其他项目不一样的对齐方式,可覆盖align-items属性。\n默认值为auto，表示继承父元素的align-items属性,如果没有父元素,则等同于stretch。 \n\n```html\nspan:nth-child(2){\n\t/* 设置自己再侧轴上的排列方式 */\n\talign-self:flex-end;\n}\n```\n\n####  order属性\n\norder属性定义子项的排列顺序（前后顺序）*\n\n 数值越小,排列越靠前，默认为0.\n\n注意：和z-index不一样\n\n## rem布局\n\n### rem基础\n\n rem页面布局可以使得文字随着屏幕大小变化而变化\n\t\t流式布局和flex布局主要针对于宽度布局,高度无法设置\n\t\trem布局让屏幕发生变化的时候元素高度和宽度等比例缩放 \n\n```css\n        p {  \n            /* 1. em相对于父元素 的字体大小来说的 */  \n            /* width: 10em; \n            height: 10em; */  \n            /* 2. rem 相对于 html元素 字体大小来说的 */  \n            width: 10rem;  \n            height: 10rem;  \n            background-color: pink;  \n            /* 3.rem的优点就是可以通过修改html里面的文字大小来改变页面中元素的大小可以整体控制 */  \n        } \n```\n\n###  **媒体查询+rem实现元素动态大小变化原理** \n\n+ rem单位是跟着html来走的，有了rem页面元素可以设置不同大小尺寸\n\n+ 媒体查询可以根据不同的设备宽度来修改样式\n\n+ 媒体查询+rem就可以实现不同设备宽度，实现页面元素大小的动态变化 \n\nrem适配方案\n\n###  **rem实际开发适配方案** \n\n *根据设计稿与设备宽度的比例,动态计算并设置html根标签的font-size大小;（媒体查询）\n*CSS中,设计稿元素的宽、高、相对位置等取值,按照同等比例换算为rem单位的值; \n\n市场上主流的rem适配方案技术\n\n(1)less+媒体查询+rem\n\n(2)flexible.js+rem(推荐)\n\n####  **rem实际开发适配方案1** \n\n#####  **(1)设计稿常见尺寸宽度** \n\n一般情况下,我们以一套或两套效果图适应大部分的屏幕,放弃极端屏,牺牲一些效果,现在基本以750px设计稿为主.\n\n#####  **(2)动态设置html标签font-size大小** \n\n+ 假设设计稿是750px\n+ 假设我们把整个屏幕划分为15等份(划分标准不一可以是20份也可以是10等份)\n+ 每一份作为Html字体大小,这里就是50px\n+ 那么在320px设备的时候,字体大小为320/15就是 21.33px\n+ 用我们页面元素的大小除以不同的html字体大小会发现它们比例还是相同的\n+ 比如我们以750px为标准设计稿,一个100*100像素的页面元素在750px屏幕下,就是100/50转换为rem是2rem * 2rem 宽高比例是1 比 1\n+ 320屏幕下,html字体大小为21.33,则2rem=42.66,此时宽和高都是42.66,但是宽和高的比例还是1比1\n+ 但是已经能实现在不同屏幕下,页面元素盒子等比例缩放的效果\n\n#####  **(3)元素大小取值方法** \n\n+ 最后的公司:页面元素的rem值=页面元素值(px)/(屏幕宽度/划分份数)\n\n+ 屏幕宽度/划分的份数 就是html font-size的大小\n\n+ 或者:页面元素的rem值=页面元素的(px)/html font-size字体大小\n\n+ 举例:\n\n  ```html\n  /* 1. 首先我们选一套标准尺寸 750为准 1280px \n     2. 我们用屏幕尺寸 除以 我们划分的份数10 得到了 html 里面的文字大小128px 但是我们知道不同屏幕下得到的文字大小是不一样的 */  \n  /* 3. 页面元素的rem值 =  页面元素在 750像素的下px值 / html 里面的文字大小128px */  \n  ```\n\n####  **rem实际开发适配方案2** \n\n#####  简洁高效的rem适配方案flexible.js\n\nflexible.js是手机淘宝团队推出的简洁高效移动端适配库,我们再也不需要在写不同屏幕的媒体查询,因为里面js做了处理,它的原理是把当前设备分为10等份,但是不同设备下,比例还是一致的.\n\n##### \t\t原理\n\n我们要做的是确定好我们当前设备的Html文字大小即可.比如当前设计稿为750px,那么我们只需要把html文字大小设置为75px(750px/10)即可,里面页面元素rem值:页面元素的px值/75,剩余的,让flexible.js去计算.\n\ngithub地址:https://github.com/amfe/lib-flexible","tags":["flex","rem","响应式布局","媒体查询"]},{"title":"移动Web开发基础","url":"/2020/03/27/移动web开发基础/","content":"\n# 移动Web开发基础\n\n## 摘要\n\n移动互联时代，手机页面开发有了多种解决方案,本文将介绍移动web开发中的概念包括视口、多倍图、移动端主流和技术解决方案（CSS的初始化文件Normalize.css和CSS3中的盒模型）以及移动端布局(Flex,Rem和响应式布局等)的内容。\n\n## 移动端基础\n\n+ PC端常见的浏览器：谷歌，火狐，Opera，IE，360，QQ，搜狗等等。\n+ 移动端常见的浏览器：UC,Opera,QQ,360,搜狗，谷歌等等。\n  国内的移动端浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。因此，对于移动端开发，我们兼容移动端主流浏览器，处理Webkit内核浏览器即可。\n+ 手机屏幕现状\n+ 移动端设备屏幕尺寸非常多，碎片化严重：\n  安卓设备有多种分辨率：480×800，480×854，540×960，720×1280，1080×1920等。\n  苹果设备碎片化也越来越严重，主要分辨率有640×960，640×1136，750×1334，1242×2208等。\n  作为开发者，我们无需关注这些分辨率，因为我们常用的尺寸单位是px。\n  常见的移动设备屏幕分布率可参考网站：https://material.io/resources/devices/\n\n\n## 视口\n\n 视口就是浏览器显示页面内容的屏幕区域，视口可分为布局视口，视觉视口和理想视口。 \n\n###  **布局视口(layout viewport）**\n\n一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的 PC 端页面在手机上显示的问题。\niOS , Android 基本都将这个视口分辨率设置为 980px ，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 \n\n###  **视觉视口(visual viewport)**\n\n字面意思，它是用户正在看到的网站的区域。 注意：是网站的区域。我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 \n\n###  **理想视口(ideal viewport)**\n\n为了使网站在移动端有最理想的浏览和阅读宽度而设定理想视口，对设备来讲，是最理想的视口尺寸需要手动添写 meta 视口标签通知浏览器操作\nmeta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽。\n\n### **标准的viewport设置**\n\n```html\n（1）视口宽度和设备保持一致\n（2）视口的默认缩放比例 1.0\n（3）最大允许的缩放比例 1.0\n（4）最小允许的缩放比例 1.0\n（5）不允许用户自行缩放 \n\n<!DOCTYPE html>  \n<html lang=\"en\">  \n<head>  \n    <meta charset=\"UTF-8\">  \n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\">  \n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">  \n    <title>Document</title>  \n</head>  \n<body>  \n</body>  \n</html> \n```\n\n## 二倍图\n\n###  **物理像素和物理像素比** \n\n 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了。\n我们开发时候的1px不是一定等于1个物理像素的。PC端页面1个px等于1个物理像素的，但是移动端就不尽相同。一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比。 \n\n PC 端和早前的手机屏幕 / 普通手机屏幕 1CSS像素 = 1物理像素的。Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里从而达到更高的分辨率，并提高屏幕显示的细腻程度。所以对于高分辨率的屏幕如Retina,不再是 1CSS像素 = 1物理像素。\n\n###  **多倍图** \n\n 对于一张 50px * 50px 的图片 在手机 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊。\n在标准的 viewport 设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题。通常使用二倍图因为iPhone 6 7 8的影响,但是现在还存在3倍图或者4倍图的情况，这个看实际开发公司需求。使用多倍图应当注意背景图片注意缩放问题。\n\n### 二倍图的做法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        /* 我们需要一个50*50像素的图片,直接放在iphone8里面会放大两倍100*100就会模糊 */\n        /* 我们采取的是放一个100*100像素的图片,然后手动把这个图片缩放为50*50(CSS像素) */\n        /* 我们准备的图片比我们实际需要的大小大2倍,这种方式就是二倍图 */      \n        img:nth-child(2) {\n            width: 50px;\n            height: 50px;\n        }\n    </style>\n</head>\n<body>\n    <!-- 模糊的 -->\n    <img src=\"images/apple50.jpg\" alt=\"\">\n    <!-- 我们采取2倍图 -->\n    <img src=\"images/apple100.jpg\" alt=\"\">\n</body>\n</html>\n```\n\n###  背景图片2倍图 \n\n```html\n<!DOCTYPE html>  \n<html lang=\"en\">  \n<head>  \n    <meta charset=\"UTF-8\">  \n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\">  \n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">  \n    <title>Document</title>  \n</head>  \n<style>  \n    /* 我们有一个50*50的背景图片需要背景图片,但是根据分析这个图片还是要准备2倍图100*100 */  \n    /* 我们需要把这个图片缩放一半,也就是50*50 通过background-size来实现*/  \n    div {  \n        width: 50px;  \n        height: 50px;  \n        border: 1px solid red;  \n        background: url(images/apple100.jpg) no-repeat;  \n        background-size: 50px 50px;  \n    }  \n    /* 3缩放问题,4pc无问题,iphone8移动端也无问题 */  \n</style>  \n<!-- 插入图片和背景图片 -->  \n<body>  \n</body>  \n</html>  \n```\n\n### 背景缩放 background-size\n\n```html\n// background-size属性规定背景图像的尺寸\nbackground-size:背景图片的宽度 背景图片的高度;\n// 单位:长度|百分比|cover|contain|auto\n// cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域\n缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪\n// contain把图像扩展值最大尺寸，以使其宽度和高度完全适应内容区域。\n缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n// auto 以背景图片的比例缩放背景图片。\n```\n\n### CSS 或 srcset 让浏览器自动切换 1X/2X/3X 图像\n\n这里介绍2个简单的方法来实现这个效果，分别是使用 [CSS](http://www.shejidaren.com/category/css/css-learn) 的媒体查询或 srcset 属性来处理这个问题。\n\n开始之前，我们要准备3张图：\n\n+ images100.jpg (为1X大小图像,100px * 100px)\n\n+ images200.jpg (为2X大小图像, 200px * 200px)\n\n+ images300.jpg (为3X大小图像, 300px * 300px)\n\n#### 方法一：使用 CSS 的`device-pixel-ratio`媒查询属性\n\n```css\n// CSS 样式代码\n/*默认大小*/\n.photo {background-image: url(image100.png);}\n/* 如果设备像素比大于等于2，则用2倍图 */\n@media screen and (-webkit-min-device-pixel-ratio: 2),\nscreen and (min--moz-device-pixel-ratio: 2) {\n  .photo {\n    background-image: url(image200.png);\n    background-size: 100px 100px;\n  }\n}\n/* 如果设备像素比大于等于3，则用3倍图 */\n@media screen and (-webkit-min-device-pixel-ratio: 3),\nscreen and (min--moz-device-pixel-ratio: 3) {\n  .photo {\n    background-image: url(image300.png);\n    background-size: 100px 100px;\n  }\n}\n.photo {width:100px;height:100px;}\n\n// SCSS的写法\n@mixin bg-image($url) {\n  background-image: url($url + \"@2x.png\");\n  @media (-webkit-min-device-pixel-ratio:3),(min-device-pixel-ratio:3){\n    background-image: url($url + \"@3x.png\")\n  }\n}\n\n// css样式中调用 bg-image 方法\ndiv{\n  width:30px;\n  height:20px;\n  background-size:30px  20px;\n  background-repeat:no-repeat;\n  @include bg-image('special_1');     \n}\n\n// html 代码\n<div class=\"photo\"></div>\n\n```\n\n#### 方法二：直接使用`<img>` 的`srcset`属性\n\n  ```html\n<img width=\"100\" height=\"100\" src=\"image100.png\" srcset=\"image200.png 2x,image300.png 3x\"/>\n\n上面代码中，浏览器会通过 srcset 属性来自动选择2X,3X图，比如用 iPhone 6s Plus，就会自动选择3x 的图像。\n\n想了解更多设备的devicePixelRatio，可查看相关网址.\n\n以上代码都需要支持 CSS3 的浏览器才能兼容，过低版本将无法看到效果。\n  ```\n\n###  **多倍图切图工具cutterman**\n\n可使用免费的Photoshop切图插件cutterman来辅助我们生成多倍图，如图所示，cutterman支持生成1-3倍图，其下载官网：http://www.cutterman.cn/zh\n\n\n## 移动端调试\n\n+ Chrome DevTools(谷歌浏览器)的模拟手机调试\n+ 搭建本地web服务器,手机和服务器一个局域网内,通过手机访问服务器\n+ 使用外网服务器，直接IP或域名访问\n\n## 移动主流方案\n\n现在的互联网公司开发移动端页面时一般采取两种可选的方案。其一是单独制作移动端页面，这也是主流，如京东，淘宝，苏宁等等；另一种方式是开发响应式页面兼容移动端，如三星手机官网等等。\n\n### **单独制作移动端页面（主流）**\n\n通常情况下，网址域名前面加m(mobile) 可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。\n\n### **响应式兼容PC移动端**\n\n通过判断屏幕宽度来改变样式，以适应不同终端。\n\n缺点：制作麻烦需要花很大精力去调兼容性问题。\n\n## 移动端技术解决方案\n\n 移动端浏览器基本以webkit 内核 为主，因此我们就不用考虑 webkit 兼容性问题。我们可以放心使用 H5 标签和 CSS3 样式 。同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可。 \n\n####  **CSS初始化（normalize.css）**\n\n移动端CSS 初始化推荐使用 normalize.css/\n官网：https://necolas.github.io/normalize.css/\nNormalize.css ：保护了有价值的默认值\nNormalize.css 修复了浏览器的 bug\nNormalize.css 是模块化的\nNormalize.css 拥有详细的文档 \n\n#### **CSS3盒模型(box-sizing)**\n\n+ 传统模式宽度计算：盒子的宽度 = CSS中设置的 width + border + padding\n+  CSS3盒子模型：盒子的宽度 = CSS 中设置的宽度width里 面包含了border和padding也就是说，我们的CSS3 中的盒子模型， padding 和 border 不会撑大盒子了。\n\n移动端可以全部采用CSS3盒模型，PC端如果完全考虑兼容性采用传统盒模型，不考虑兼容采用CSS3盒模型。\n\n```css\n/* CSS3盒子模型 */  \nbox-sizing: border box;  \n/* 传统盒子模型 */  \nbox-sizing: content box;  \n```\n\n#### 特殊样式\n\n我们需要针对不同浏览器设置一些特殊样式以提升用户体验\n\n```css\n/*CSS3盒子模型*/  \nbox-sizing: border-box;  \n-webkit-box-sizing: border-box;  \n/*点击高亮我们需要清除清除设置为 transparent完成透明*/  \n-webkit-tap-highlight-color: transparent;  \n在移动端浏览器默认的外观 在 iOS 上加上这个属性才能给按钮和输入框自定义样式*/  \n-webkit-appearance: none;  \n/*禁用长按页面时的弹出菜单*/  \nimg,a  \n{-webkit-touch-callout: none; }  \n```\n\n## 移动端常见布局\n\n+ 淡出制作移动端页面(主流)\n  + 流式布局(百分比布局)\n  + flex弹性布局(推荐)\n  + less+媒体查询+rem/flexible.js+rem(淘宝公司提出的移动端布局解决方案)\n  + 混合布局(布局中混合使用rem和flex等)\n+ 响应式页面兼容移动端\n  + 媒体查询\n  + bootstrap前端UI组件库","tags":["移动开发"]},{"title":"版本管理软件Git和GitHub用法总结","url":"/2020/03/26/版本管理软件Git和GitHub用法总结/","content":"\n## 1. Git基础\n\n### 1.1 版本管理\n\n#### 1.1.1 什么是版本管理\n\n版本管理是一种记录文件变化的方式，以便将来查阅特定版本的文件内容。\n\n![](版本管理软件Git和GitHub用法总结/01.png)\n\n#### 1.1.2 人为维护文档版本的问题\n\n1. 文档数量多且命名不清晰导致文档版本混乱\n\n2. 每次编辑文档需要复制，不方便\n\n3. 多人同时编辑同一个文档，容易产生覆盖\n\n\n\n\n![](版本管理软件Git和GitHub用法总结/04.png)\n\n\n\n### 1.2 Git 是什么\n\nGit是一个版本管理控制系统（缩写VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复回来。\n\n\n\n![](版本管理软件Git和GitHub用法总结/19.png)\n\n### 1.3 Git 安装\n\n[下载地址](https://git-scm.com/downloads) \n\n在安装的过程中，所有选项使用默认值即可。\n\n\n\n### 1.4 Git 基本工作流程\n\n| git仓库          | 暂存区             | 工作目录            |\n| ---------------- | ------------------ | ------------------- |\n| 用于存放提交记录 | 临时存放被修改文件 | 被Git管理的项目目录 |\n\n![](版本管理软件Git和GitHub用法总结/05.png)\n\n### 1.5 Git 的使用\n\n#### 1.5.1 Git 使用前配置\n\n在使用 git 前，需要告诉 git 你是谁，在向 git 仓库中提交时需要用到。\n\n1. 配置提交人姓名：`git config --global user.name 提交人姓名`\n2. 配置提交人姓名：`git config --global user.email 提交人邮箱` \n3. 查看git配置信息：`git config --list`   \n\n**注意**\n\n1. 如果要对配置信息进行修改，重复上述命令即可。\n\n2. 配置只需要执行一次。\n\n#### 1.5.2 提交步骤\n\n1. `git init` 初始化git仓库\n2. `git status` 查看文件状态\n3. `git add 文件列表` 追踪文件\n4. `git commit -m 提交信息`  向仓库中提交代码\n5. `git log` 查看提交记录\n\n#### 1.5.3 撤销\n\n- 用暂存区中的文件覆盖工作目录中的文件： `git checkout 文件`\n\n- 将文件从暂存区中删除： `git rm --cached 文件`\n- 将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：`git rest --hard commitID` \n\n![](版本管理软件Git和GitHub用法总结/07.png)\n\n\n\n## 2. Git进阶\n\n### 2.1 分支\n\n为了便于理解，大家暂时可以认为分支就是当前工作目录中代码的一份副本。\n\n使用分支，可以让我们从开发主线上分离出来，以免影响开发主线。\n\n![](版本管理软件Git和GitHub用法总结/08.png)\n\n\n\n#### 2.1.1 分支细分\n\n1. 主分支（master）：第一次向 git 仓库中提交更新记录时自动产生的一个分支。\n\n   \n\n   ![](版本管理软件Git和GitHub用法总结/06.png)\n\n   \n\n2. 、开发分支（develop）：作为开发的分支，基于 master 分支创建。\n\n   \n\n   ![](版本管理软件Git和GitHub用法总结/09.png)\n\n3. 功能分支（feature）：作为开发具体功能的分支，基于开发分支创建\n\n   \n\n   ![](版本管理软件Git和GitHub用法总结/10.png)\n\n**功能分支 -> 开发分支 -> 主分支**\n\n#### 2.1.2 分支命令\n\n- `git branch` 查看分支\n\n- `git branch 分支名称` 创建分支\n\n- `git checkout 分支名称` 切换分支\n\n- `git merge 来源分支` 合并分支\n\n- `git branch -d 分支名称` 删除分支（分支被合并后才允许删除）（-D 强制删除）\n\n\n### 2.2 暂时保存更改\n\n在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作。\n\n使用场景：分支临时切换\n\n- 存储临时改动：`git stash`\n- 恢复改动：`git stash pop`\n\n## 3. Github\n\n在版本控制系统中，大约90%的操作都是在本地仓库中进行的：暂存，提交，查看状态或者历史记录等等。除此之外，如果仅仅只有你一个人在这个项目里工作，你永远没有机会需要设置一个远程仓库。\n\n只有当你需要和你的开发团队共享数据时，设置一个远程仓库才有意义。你可以把它想象成一个 “文件管理服务器”，利用这个服务器可以与开发团队的其他成员进行数据交换。\n\n### 3.1 注册\n\n1. 访问[github](https://github.com/)首页，点击 Sign up 连接。（注册）\n\n   ![](版本管理软件Git和GitHub用法总结/11.png)\n\n2. 填写用户名、邮箱地址、GitHub登陆密码\n\n   ![](版本管理软件Git和GitHub用法总结/12.png)\n\n3. 选择计划\n\n   ![](版本管理软件Git和GitHub用法总结/13.png)\n\n4. 填写 GitHub 问题\n\n   ![](版本管理软件Git和GitHub用法总结/14.png)\n\n5. 验证邮箱\n\n   ![](版本管理软件Git和GitHub用法总结/15.png)\n\n6. GitHub 个人中心\n\n   ![](版本管理软件Git和GitHub用法总结/16.png)\n\n\n\n### 3.2 多人协作开发流程\n\n- A在自己的计算机中创建本地仓库\n- A在github中创建远程仓库\n- A将本地仓库推送到远程仓库\n- B克隆远程仓库到本地进行开发\n- B将本地仓库中开发的内容推送到远程仓库\n- A将远程仓库中的最新内容拉去到本地\n\n![](版本管理软件Git和GitHub用法总结/20.png)\n\n\n\n![](版本管理软件Git和GitHub用法总结/21.png)\n\n### 3.3 创建仓库\n\n1. 填写仓库基本信息\n\n   ![](版本管理软件Git和GitHub用法总结/17.png)\n\n2. 将本地仓库推送到远程仓库\n\n   ![](版本管理软件Git和GitHub用法总结/18.png)\n\n   1. git push 远程仓库地址 分支名称\n\n   2. git push 远程仓库地址别名 分支名称\n\n   3. git push -u 远程仓库地址别名 分支名称\n\n       -u 记住推送地址及分支，下次推送只需要输入git push即可\n\n   4. git remote add 远程仓库地址别名 远程仓库地址\n\n### 3.4 拉取操作\n\n#### 3.4.1 克隆仓库\n\n克隆远端数据仓库到本地：`git clone 仓库地址`\n\n#### 3.4.2 拉取远程仓库中最新的版本\n\n拉取远程仓库中最新的版本：`git pull 远程仓库地址 分支名称`\n\n### 3.5 解决冲突\n\n在多人同时开发一个项目时，如果两个人修改了同一个文件的同一个地方，就会发生冲突。冲突需要人为解决。\n\n### 3.6 跨团队协作\n\n1. 程序员 C fork仓库\n2. 程序员 C 将仓库克隆在本地进行修改\n3. 程序员 C 将仓库推送到远程\n4. 程序员 C 发起pull reqest\n5. 原仓库作者审核\n6. 原仓库作者合并代码\n\n### 3.7 ssh免登陆\n\nhttps协议仓库地址：https://github.com/itcast-frontEnd/git-demo.git\n\n\n\n![](版本管理软件Git和GitHub用法总结/22.png)\n\n生成秘钥：`ssh-keygen`\n\n秘钥存储目录：C:\\Users\\用户\\\\.ssh\n\n公钥名称：id_rsa.pub\n\n私钥名称：id_rsa\n\n![](版本管理软件Git和GitHub用法总结/23.png)\n\n![](版本管理软件Git和GitHub用法总结/24.png)\n\n### 3.8 GIT忽略清单\n\n将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。\n\ngit忽略清单文件名称：**.gitignore**\n\n将工作目录中的文件全部添加到暂存区：`git add .`","tags":["Git","GitHub"]},{"title":"Vue模板语法","url":"/2020/03/26/Vue模板语法/","content":"\n# Vue基础\n\n## vue概述\n\n+ 作者:尤雨溪 ,中国国籍\n\n+ 官网:https://cn.vuejs.org/v2/guide/\n\n+ 发展：\n\n  + 2014年2月,vue.js正式发布\n\n  + 2015年10月27日正式发布1.0.0\n\n  + 2016年4月27日,发布2.0的预览版本\n\n+ 特点:渐进式的javascript框架（库侧重于提供各种API，如jquery，而框架则侧重于提供基础性服务,如vue中虚拟DOM和双向数据绑定等等.）,易用、灵活、高效。\n\n+ 渐进式:声明式渲染=>组件系统=>客户端路由=>集中式状态管理=>项目构建，\n\n  + Vue有包含了许多功能,渐进式意味着你可以根据项目的需求选择使用Vue框架的功能\n\n  + 易用:熟悉HTML、CSS、javaScript知识后可以快速上手vue\n\n  + 灵活:在一个库和一套完整框架之间自如收缩\n\n  + 高效:20kB运行大小,超快虚拟DOM\n\n## vue的基本用法\n\n### 实例参数分析\n\n+ el:元素的挂载位置（值可以是CSS选择器或者DOM元素）\n+ data:模型数据(值是一个对象)\n+ {{msg}}：我们称为插值表达式，其作用是将数据填充到HTML标签中,插值表达式还支持基本的计算操作\n\n\t\t<div id=\"app\">\n\t        <div>{{msg}}</div>\n\t        <div>{{1 + 2}}</div>\n\t        <div>{{msg + '----' + 123}}</div>\n\t    </div>\n\t    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n\t    <script type=\"text/javascript\">\n\t        /*\n\t              Vue的基本使用步骤\n\t              1、需要提供标签用于填充数据\n\t              2、引入vue.js库文件\n\t              3、可以使用vue的语法做功能了\n\t              4、把vue提供的数据填充到标签里面\n\t            */\n\t        var vm = new Vue({\n\t            el: '#app',\n\t            data: {\n\t                msg: 'Hello Vue'\n\t            }\n\t        });\n\t    </script>\n\n## vue的模板语法\n\n### 模板语法概述\n\n前端渲染：将模板和数据在前端生成静态的有样式的HTML内容呈现在用户面前的过程。\n\n前端渲染的方式：!\n\n+ (1)原生js拼接字符串：基本上就是将数据以字符串的方式拼接到HTML标签中,缺点在于随着业务的复杂，维护会变得异常困难。\n\n+ (2)使用前端模板引擎（如art-template等等）：代码相比拼接字符串更加规范,可读性高，方便后期的维护，但是没有专门提供事件的处理机制，还是不够完美。\n\n+ (3)使用vue特有的模板语法：\n\n  + 插值表达式\n  \n  + 指令\n  \n  + 事件绑定\n  \n  + 属性绑定\n  \n  + 样式绑定\n  \n  + 分支循环结构\n\n### mvvm开发模型\n\n- MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n- m   model  \n  - 数据层   Vue  中 数据层 都放在 data 里面\n- v   view     视图   \n  - Vue  中  view      即 我们的HTML页面  \n- vm   （view-model）     控制器     将数据和视图层建立联系      \n  - vm 即  Vue 的实例  就是 vm  \n\n### 数据响应式与数据绑定\n\n数据响应式\n\n如何理解响应式？\n\n1.html5中的响应式（屏幕尺寸的变化导致样式的变化）\n\n2.数据的响应式（数据的变化导致页面内容的变化，数据驱动视图）\n\n什么是数据绑定？\n\n数据绑定：将数据填充到标签中\n\n事件函数/方法的调用方式有两种,this指的是vue的实例对象vm\n\n```html\n(1)直接绑定函数名称\n<button v-on:click='say'>Hello</button>\n(2)调用函数\n<button v-on:click='say()'>Say hi</button>\n```\n\n事件函数的参数传递\n\n```javascript\n(1)普通参数和事件对象$event/$e=>调用event.target\n<button v-on:click='say(\"hi\",$event)'></button>\n```\n\n### vue指令\n\n- 本质就是自定义属性\n- Vue中指定都是以 v- 开头，指令的格式：以v-开始(如v-cloak)\n\n属性：如`<form>`标签中的`action`和`<a>`标签中的`href`\n\n自定义属性：如html5中的`data-`自定义属性的定义方式,指令的本本质就是自定义属性\n\n####  v-cloak\n\n- 防止页面加载时插值表达式出现闪烁的问题。解决该问题的原理：先隐藏,替换号值之后再显示最终的值。\n\n  ```html\n   <style type=\"text/css\">\n    /* \n      1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏\n   */\n    [v-cloak]{\n      /* 元素隐藏    */\n      display: none;\n    }\n    </style>\n  <body>\n    <div id=\"app\">\n      <!-- 2、 让带有插值 语法的   添加 v-cloak 属性 \n           在 数据渲染完场之后，v-cloak 属性会被自动去除，\n           v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签\n  \t\t 也就是对应的标签会变为可见\n  \t\t背后的原理：先通过样式隐藏内容，然后在内存中进行值的替换，替换好之后再显示\t\t最终的结果\n      -->\n      <div  v-cloak  >{{msg}}</div>\n    </div>\n    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n    <script type=\"text/javascript\">\n      var vm = new Vue({\n        //  el   指定元素 id 是 app 的元素  \n        el: '#app',\n        //  data  里面存储的是数据\n        data: {\n          msg: 'Hello Vue'\n        }\n      });\n  </script>\n  </body>\n  </html>\n  ```\n  \n\n####  v-text\n\n- v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题\n- 如果数据中有HTML标签会将html标签一并输出\n- 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值\n\n```html\n<div id=\"app\">\n    <!--  \n\t\t注意:在指令中不要写插值语法  直接写对应的变量名称 \n        在 v-text 中 赋值的时候不要在写 插值语法\n\t\t一般属性中不加 {{}}  直接写 对应 的数据名 \n\t-->\n    <p v-text=\"msg\"></p>\n    <p>\n        <!-- Vue  中只有在标签的 内容中 才用插值语法 -->\n        {{msg}}\n    </p>\n</div>\n\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n\n</script>\n```\n\n####  v-html\n\n- 用法和v-text 相似  但是他可以将HTML片段填充到标签中\n\n- 可能有安全问题, 一般只在可信任内容上使用 `v-html`，**永不**用在用户提交的内容上\n\n- 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。\n\n  ```html\n  <div id=\"app\">\n  　　<p v-html=\"html\"></p> <!-- 输出：html标签在渲染的时候被解析 -->\n      \n      <p>{{message}}</p> <!-- 输出：<span>通过双括号绑定</span> -->\n      \n  　　<p v-text=\"text\"></p> <!-- 输出：<span>html标签在渲染的时候被源码输出</span> -->\n  </div>\n  <script>\n  　　let app = new Vue({\n  　　el: \"#app\",\n  　　data: {\n  　　　　message: \"<span>通过双括号绑定</span>\",\n  　　　　html: \"<span>html标签在渲染的时候被解析</span>\",\n  　　　　text: \"<span>html标签在渲染的时候被源码输出</span>\",\n  　　}\n   });\n  </script>\n  ```\n\n####  v-pre\n\n- 显示原始信息跳过编译过程\n- 跳过这个元素和它的子元素的编译过程。\n- **一些静态的内容不需要编译加这个指令可以加快渲染**\n\n```html\n    <span v-pre>{{ this will not be compiled }}</span>    \n\t<!--  显示的是{{ this will not be compiled }}  -->\n\t<span v-pre>{{msg}}</span>  \n     <!--   即使data里面定义了msg这里仍然是显示的{{msg}}  -->\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n\n</script>\n```\n\n#### **v-once**\n\n- 执行一次性的插值【当数据改变时，插值处的内容不会继续更新】\n\n```html\n  <!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  -->\n/v-once的应用场景：如果显示的信息后续不需要再修改，你们可以使用v-once，这样可以提高性能。/\n     <span v-once>{{ msg}}</span>    \n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n</script>\n```\n\nVue模板语法\n\n### 样式绑定\n\n1.class样式处理\n\n```html\n(1)对象语法\n<div v-bind:class=\"{active:isActive}\"></div>\n(2)数组语法\n<div v-bind:class=\"{activeClass,errorClass}\"></div>\n```\n\n2.style样式处理\n\n```html\n(1)对象语法:\n<div v-bind:style=\"{color:activeColor,fontSize:fontSize}\"></div>\n(2)数组语法\n<div v-bind:style=\"{baseStyles,overridingStyles}\"></div>\n```\n\n### 分支循环结构\n\n循环结构\n\n1.v-for遍历数组\n\n```html\n<li v-for='item in list'>{{item}}</li>\n<li v-for='{item,index} in list'>{{item}} + '---' + {{index}}</li>\n```\n\n2.key的作用:帮助Vue区分不同的元素，从而提高性能\n\n```html\n<li :key='item.id' v-for='{item,index} in list'>{{item}} + '---' {{index}}</li>\n```\n\n3.v-for遍历对象\n\n```html\n<div v-for='(value,key,index) in object'></div>\n```\n\n4.v-if和v-for结合使用\n\n```html\n<div v-if='value==12' v-for='(value,key,index) in object'></div>\n```\n\n### 双向数据绑定\n\n- 当数据发生变化的时候，视图也就发生变化\n- 当视图发生变化的时候，数据也会跟着同步变化\n\n#### v-model\n\n- **v-model**是一个指令，限制在 `<input>、<select>、<textarea>、components`中使用\n\n```html\n      /*\n        双向数据绑定\n        1、从页面到数据\n        2、从数据到页面\n      */ \n<div id=\"app\">\n      <div>{{msg}}</div>\n      <div>\n          当输入框中内容改变的时候，  页面上的msg  会自动更新\n        <input type=\"text\" v-model='msg'>\n      </div>\n  </div>\n```\nv-model的底层实现原理分析\n\n```html\n<input v-bind:value=\"msg\" v-on:input=\"msg=$event.target.value\">\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"app\">\n    <div>{{msg}}</div>\n    <input type=\"text\" v-bind:value=\"msg\" v-on:input='handle'>\n    <input type=\"text\" v-bind:value=\"msg\" v-on:input='msg=$event.target.value'>\n    <input type=\"text\" v-model='msg'>\n  </div>\n  <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n  <script type=\"text/javascript\">\n    /*\n      v-model指令的本质\n\n    */\n    var vm = new Vue({\n      el: '#app',\n      data: {\n        msg: 'hello'\n      },\n      methods: {\n        handle: function(event){\n          // 使用输入域中的最新的数据覆盖原来的数据\n          this.msg = event.target.value;\n        }\n      }\n    });\n  </script>\n</body>\n</html>\n\n```\n\n####   v-on\n\n- 用来绑定事件的\n-  形式如：v-on:click  缩写为 @click;\n\n#####  v-on事件函数中传入参数\n\n```html\n\n<body>\n    <div id=\"app\">\n        <div>{{num}}</div>\n        <div>\n            <!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 -->\n            <button v-on:click='handle1'>点击1</button>\n            <!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，\n                 并且事件对象的名称必须是$event \n            -->\n            <button v-on:click='handle2(123, 456, $event)'>点击2</button>\n        </div>\n    </div>\n    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n    <script type=\"text/javascript\">\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                num: 0\n            },\n            methods: {\n                handle1: function(event) {\n                    console.log(event.target.innerHTML)\n                },\n                handle2: function(p, p1, event) {\n                    console.log(p, p1)\n                    console.log(event.target.innerHTML)\n                    this.num++;\n                }\n            }\n        });\n    </script>\n```\n\n#####  事件修饰符\n\n- 在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。\n- Vue 不推荐我们操作DOM    为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**\n- 修饰符是由点开头的指令后缀来表示的\n\n```html\n(1).stop阻止冒泡\n<a v-on:click.stop=\"handle\">跳转</a>\n(2).prevent阻止默认行为\n<a v-on:click.prevent=\"handle\">跳转</a>\n\n<!-- 阻止单击事件继续传播 -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n```\n\n##### 按键修饰符\n\n- 在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符\n\n```html\n.enter回车键\n<input v-on:keyup.enter='submit'>\n.delete删除键\n<input v-on:keyup.delete='handle'>\n\n<!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` -->\n<input v-on:keyup.13=\"submit\">\n\n<!-- -当点击enter 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n\n<!--当点击enter或者space时  时调用 `vm.alertMe()`   -->\n<input type=\"text\" v-on:keyup.enter.space=\"alertMe\" >\n\n常用的按键修饰符\n.enter =>    enter键\n.tab => tab键\n.delete (捕获“删除”和“退格”按键) =>  删除键\n.esc => 取消键\n.space =>  空格键\n.up =>  上\n.down =>  下\n.left =>  左\n.right =>  右\n\n<script>\n\tvar vm = new Vue({\n        el:\"#app\",\n        methods: {\n              submit:function(){},\n              alertMe:function(){},\n        }\n    })\n\n</script>\n```\n\n##### 自定义按键修饰符别名\n\n- Vue的按键修饰符默认支持数字不够直观，在Vue中可以通过全局`config.keyCodes`对象自定义按键修饰符别名,\n- 规则：自定义按键修饰符名字是自定义的，但是对应的值必须是按键对应event.keyCode值\n\n```html\n<div id=\"app\">\n    预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法\n    <input type=\"text\" v-on:keydown.f5=\"prompt()\">\n</div>\n\n<script>\n\t\n    Vue.config.keyCodes.f5 = 116;\n\n    let app = new Vue({\n        el: '#app',\n        methods: {\n            prompt: function() {\n                alert('我是 F5！');\n            }\n        }\n    });\n</script>\n```\n\n#### v-bind\n\n- v-bind 指令被用来响应地更新 HTML 属性\n- v-bind:href    可以缩写为    :href;\n\n```html\n<!-- 绑定一个属性 -->\n<img v-bind:src=\"imageSrc\">\n\n<!-- 缩写 -->\n<img :src=\"imageSrc\">\n```\n\n##### 绑定对象\n\n- 我们可以给v-bind:class 一个对象，以动态地切换class。\n- 注意：v-bind:class指令可以与普通的class特性共存\n\n```html\n1、 v-bind 中支持绑定一个对象 \n\t如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据 \n<!-- \n\tHTML最终渲染为 <ul class=\"box textColor textSize\"></ul>\n\t注意：\n\t\ttextColor，textSize  对应的渲染到页面上的CSS类名\t\n\t\tisColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上 \n\n\n\t\t当 isColor 和 isSize 变化时，class列表将相应的更新，\n\t\t例如，将isSize改成false，\n\t\tclass列表将变为 <ul class=\"box textColor\"></ul>\n-->\n\n<ul class=\"box\" v-bind:class=\"{textColor:isColor, textSize:isSize}\">\n    <li>学习Vue</li>\n    <li>学习Node</li>\n    <li>学习React</li>\n</ul>\n  <div v-bind:style=\"{color:activeColor,fontSize:activeSize}\">对象语法</div>\n\n<sript>\nvar vm= new Vue({\n    el:'.box',\n    data:{\n        isColor:true,\n        isSize:true，\n    \tactiveColor:\"red\",\n        activeSize:\"25px\",\n    }\n})\n</sript>\n<style>\n\n    .box{\n        border:1px dashed #f0f;\n    }\n    .textColor{\n        color:#f00;\n        background-color:#eef;\n    }\n    .textSize{\n        font-size:30px;\n        font-weight:bold;\n    }\n</style>\n```\n\n######  1.绑定class\n\n```html\n2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据\n\n这里的classA  对用data 中的  classA\n这里的classB  对用data 中的  classB\n/*\n      样式绑定相关语法细节：\n      1、对象绑定和数组绑定可以结合使用\n      2、class绑定的值可以简化操作\n      3、默认的class如何处理？默认的class会保留\n      \n    */\n<ul class=\"box\" :class=\"[classA, classB]\">\n    <li>学习Vue</li>\n    <li>学习Node</li>\n    <li>学习React</li>\n</ul>\n<script>\nvar vm= new Vue({\n    el:'.box',\n    data:{\n        classA:‘textColor‘,\n        classB:‘textSize‘\n    }\n})\n</script>\n<style>\n    .box{\n        border:1px dashed #f0f;\n    }\n    .textColor{\n        color:#f00;\n        background-color:#eef;\n    }\n    .textSize{\n        font-size:30px;\n        font-weight:bold;\n    }\n</style>\n```\n\n##### 绑定对象和绑定数组 的区别\n\n- 绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 \n- 绑定数组的时候数组里面存的是data 中的数据 \n\n###### 2.绑定style\n\n```html\n <div v-bind:style=\"styleObject\">绑定样式对象</div>'\n \n<!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    -->\n <div v-bind:style=\"{ color: activeColor, fontSize: fontSize,background:'red' }\">内联样式</div>\n\n<!--组语法可以将多个样式对象应用到同一个元素 -->\n<div v-bind:style=\"[styleObj1, styleObj2]\"></div>\n\n\n<script>\n\tnew Vue({\n      el: '#app',\n      data: {\n        styleObject: {\n          color: 'green',\n          fontSize: '30px',\n          background:'red'\n        }，\n        activeColor: 'green',\n   \t\tfontSize: \"30px\"\n      },\n      styleObj1: {\n             color: 'red'\n       },\n       styleObj2: {\n            fontSize: '30px'\n       }\n\n</script>\n```\n\n### 分支结构\n\nv-if\n\nv-else\n\nv-else-if\n\nv-show\n\n#### v-if\n\n- 1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素\n- 2- 进行两个视图之间的切换\n\n```html\n<div id=\"app\">\n        <!--  判断是否加载，如果为真，就加载，否则不加载-->\n        <span v-if=\"flag\">\n           如果flag为true则显示,false不显示!\n        </span>\n</div>\n\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data:{\n            flag:true\n        }\n    })\n</script>\n\n----------------------------------------------------------\n\n    <div v-if=\"type === 'A'\">\n       A\n    </div>\n  <!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行-->\n    <div v-else-if=\"type === 'B'\">\n       B\n    </div>\n    <div v-else-if=\"type === 'C'\">\n       C\n    </div>\n  <!-- v-else紧跟在v-if或v-else-if之后-->\n    <div v-else>\n       Not A/B/C\n    </div>\n\n<script>\n    new Vue({\n      el: '#app',\n      data: {\n        type: 'C'\n      }\n    })\n</script>\n```\n\n#### v-show 和 v-if的区别\n\n- v-show本质就是标签display设置为none，控制隐藏\n  - v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。\n- v-if是动态的向DOM树内添加或者删除DOM元素\n  - v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件\n\n### 循环结构\n\n#### v-for\n\n- 用于循环的数组里面的值可以是对象，也可以是普通元素  \n\n```html\n<ul id=\"example-1\">\n   <!-- 循环结构-遍历数组  \n\titem 是我们自己定义的一个名字  代表数组里面的每一项  \n\titems对应的是 data中的数组-->\n  <li v-for=\"item in items\">\n    {{ item.message }}\n  </li> \n\n</ul>\n<script>\n new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]，\n   \n  }\n})\n</script>\n```\n\n- **不推荐**同时使用 `v-if` 和 `v-for`\n- 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。\n\n```html\n   <!--  循环结构-遍历对象\n\t\tv 代表   对象的value\n\t\tk  代表对象的 键 \n\t\ti  代表索引\t\n\t---> \n     <div v-if='v==13' v-for='(v,k,i) in obj'>{{v + '---' + k + '---' + i}}</div>\n\n<script>\n new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]，\n    obj: {\n        uname: 'zhangsan',\n        age: 13,\n        gender: 'female'\n    }\n  }\n})\n</script>\n```\n\n- key 的作用\n  - **key来给每个节点做一个唯一标识**\n  - **key的作用主要是为了高效的更新虚拟DOM**\n\n```html\n<ul>\n  <li v-for=\"item in items\" :key=\"item.id\">...</li>\n</ul>\n```","tags":["Vue"]},{"title":"DiagramDesigner用法总结","url":"/2020/03/25/DiagramDesigner用法总结/","content":"\n# DiagramDesigner\n\n## 摘要\n\nDiagramDesigner是一款专门用于绘制流程图的软件,该软件具有支持中文，易于上手,体积小,开源免费等优点,本文将介绍如何快速上手DiagramDesigner。\n\n## 下载安装\n\n>  https://meesoft.logicnet.dk/DiagramDesigner/ \n\n## 使用\n\n软件界面分为左中右三块,左侧为结构区,中部为绘图区域，右侧为素材区,\n\n素材区域将选择的素材拖到中部即可完成绘图\n\n+ 填充字体和应用：双击鼠标填充字体,右键属性（可设置字体颜色大小边距等等）, 要想达到透明的效果，可依次选择属性=>风格=>填充颜色选择为空\n+ 重叠对象优先级设置:右键=>提升显示优先级/降低显示优先级\n\n### 图片的导出\n\n文件=>导出当前页=>选择一种文件形式,png/jeg等格式都可以","tags":["DiagramDesigner"]},{"title":"XMind用法总结","url":"/2020/03/24/XMind用法总结/","content":"# XMind的基本使用\n\n## 摘要\n\nXMind是一款绘制思维导图的软件，其能帮助我们有效提升工作和生活效率的生产力,本文将介绍XMind的基本入门使用。\n\n## 使用\n\n### 安装\n\n>  https://www.xmind.cn/ \n\n### 创建使用\n\n> Ctrl+N => 选择结构=>选择风格\n\n### 快捷键\n\n+ 文件\n  \n   + 新建思维导图 `Ctrl`+`N`\n+ 编辑\n   + 删除单个主题 `Delete`/`Backspace`\n   + 拷贝样式 `Ctrl`+`Alt`+`C`\n   + 粘贴样式 `Ctrl`+`Alt`+`V`\n   + 折叠/展开子主题 `Ctrl`+`/`\n+ 插入\n   + 主题（之后）`Enter`\n   + 子主题 `Tab`\n   + 主题(之前) `Shift`+`Enter`\n   + 父主题(之前) `Ctrl`+`Enter`\n   + 超链接 - 网页 `Ctrl` + `K`\n   + 联系 `Ctrl`+ `Shift`+`L`\n   + 外框 `Ctrl`+ `Shift`+`B`\n   + 笔记 `Ctrl`+ `Shift`+`N`\n+ 查看\n   + 放大 `Ctrl`+`=`\n   + 缩小 `Ctrl`+`-`\n   + 实际大小 `Ctrl`+`0`\n   + ZEN模式 `Ctrl`+`Alt`+`F`\n   + 显示格式面板 `Ctrl`+`i`\n   + 切换至导图/大纲 `Ctrl`+`Shift`+`M`\n+ 制作完成后,导出为图片","tags":["XMind"]},{"title":"http-server的安装和使用","url":"/2020/03/23/http-server的安装和使用/","content":"# http-server的安装和使用\n\n## 问题起源\n\n为了解决three.js的跨域问题：在学习three.js的过程中,对模型的纹理设置图片的时候本地运行html文件会出现跨域问题无法正常显示。代码段如下所示：\n\n```javascript\n    const texture = new THREE.TextureLoader().load('../img/texture2.png');\n    const material = new THREE.MeshBasicMaterial({ map: texture });\n```\n\n解决方案： 解决方案就是在本地自定义服务器，可以通过nodejs、python等任何一个你熟悉的语言来创建本地服务器解决。 \n\n使用Nodejs自定义服务器很简单，需要安装http-server就可以完成本地服务器创建。\n\n## http-server介绍\n\nhttp-server是一个轻量级的基于Nodejs的http服务器，故需要先安装Node.js,http-server可以使项目中的任意一个目录成为服务器的目录,完全抛开后台的沉重工程,直接运行想要的js代码.\n\n## 使用\n\n```shell\n# 安装\nnpm i -g http-server\n# 运行 在要成为服务器的目录下运行如下命令\nhttp-server\n# 若要禁用缓存，请使用如下命令运行\nhttp-server -c-1\n# 结果 浏览器输入下列url即可打开本地项目\nStarting up http-server, serving ./\nAvailable on:\n  http://192.168.36.1:8080\n  http://192.168.200.1:8080\n  http://192.168.43.188:8080\n  http://127.0.0.1:8080\n# 停止运行 终端显示http-server stopped.即关闭服务成功。\nCTrl+C\n```","tags":["http-server"]},{"title":"markdown语法总结","url":"/2020/03/22/markdown语法总结/","content":"# Markdown语法\n\n## 摘要\n\nmarkdown语法是一种轻量级的标记语言,具有纯文本格式语法，可将其转换为结构上有效的XHTML或HTML。markdown编写的文件后缀是.md,在github项目仓库的README.md和Typora都有markdown的应用.\n\n## 标题\n\n标题分为6个层级， 注意：#与标题之间最好空有一格 \n\n```html\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n预览:\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n## 字体\n\n```html\n**加粗** __加粗__\n\n*斜体* _斜体_\n\n***斜体加粗***\n\n~~删除线~~\n```\n预览:\n**加粗** __加粗__\n\n*斜体* _斜体_\n\n***斜体加粗***\n\n~~删除线~~\n## 引用\n\n引用支持嵌套\n\n```html\n> 重剑无锋，大巧不工。\n```\n预览:\n> 重剑无锋，大巧不工。\n\n## 分割线\n\n 在markdown语法中,一行连用三个或者三个以上的星号,减号,或者下划线,就可以表示分割线。可以在一行用3个以上的 `*` `-` `_`来建立一条分割线，行内除了空格不能有其他东西。 \n\n```html\n*** 这里是分割线  \n--- 这里也是分割线  \n__ 这里还是分割线  \n```\n\n预览:\n\n*** 这里是分割线\n\n## 图片\n\n```html\n![图片alt](图片地址  \"optional title\")\n// 图片alt就是显示在图片下面的文字，相当于对图片内容的解释，可以不写。\n// 图片地址链接可以是图片的本地地址或网址。\n// 图片optional title是图片的标题，当鼠标悬置于图片上时显示的内容。title可加可不加。\n```\n\n## 超链接\n\n```html\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n文字链接 [链接名称](http://链接网址)\n网址链接 <http://链接网址>\n实例：\n[苹果](https://www.apple.com) &emsp;<https://www.github.com>\n[Github](https://www.github.com/ \"Github\")\n```\n\n+ [苹果](https://www.apple.com)\n+ <https://www.github.com>\n+ [Github](https://www.github.com/ \"Github\")\n\n## 列表\n\n有序列表: 数字加点，序号与内容间需要留空格。\n\n```html\n1. 列表内容\n2. 列表内容\n3. 列表内容\n```\n\n预览:\n\n1.  列表内容\n2.  列表内容\n3.  列表内容\n\n无序列表:`+` `-` `*`这三个符号均可以，注意符号与列表内容之间要留一个空格,无序列表支持嵌套。\n\n```html\n- 列表内容\n+ 列表内容\n* 列表内容\n```\n\n预览：\n\n- 列表内容\n+ 列表内容\n\n* 列表内容\n\n## 表格\n\n```html\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n```\n\n预览：\n\n| 表头 |   表头   |     表头 |\n| ---- | :------: | -------: |\n| 内容 | 内容居中 | 内容居右 |\n| 内容 | 内容居中 | 内容居右 |\n\n## 代码块\n\n+ 单行代码\n\n```html\n`create database`\n```\n预览：\n`create database`\n\n+ 多行代码\n\n```html\n​``` var users = [\n  {id: 1, name: '张三'},\n  {id: 2, name: '张三'},\n  {id: 3, name: '张三'},\n  {id: 4, name: '张三'}\n]\n```\n\n预览:\n\n```html\nvar users = [\n  {id: 1, name: '张三'},\n  {id: 2, name: '张三'},\n  {id: 3, name: '张三'},\n  {id: 4, name: '张三'}\n]\n```\n\n","tags":["markdown"]},{"title":"Echart.js知识点汇总","url":"/2020/03/20/Echart.js知识点汇总/","tags":["前端"]},{"title":"Canvas知识点汇总","url":"/2020/03/20/Canvas知识点汇总/","tags":["Canvas"]},{"title":"Node.js学习笔记","url":"/2020/03/20/Node.js学习笔记/","content":"\n# Node.js\n\n## 1.Node.js介绍\n\n### 1.1. 为什么要学习Node.js\n\n企业需求\n\n- 具有服务端开发经验更好\n+ front-end\n+ back-end\n+ 全栈开发工程师\n+ 基本的网站开发能力\n   * 服务端 后端开发语言:Java,PHP,Python,Ruby(Github后端),.Net,JavaScript(Node.js)...\n   * 前端\n   * 运维部署\n+ 多人社区\n\n### 1.2. Node.js是什么？\n\n+ Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.\n   * Node.js不是一门语言\n   * Node.js不是库,不是框架\n   * Node.js是一个JavaScript运行时环境\n   * 简单点来讲就是Node.js可以解析和执行JavaScript代码\n   * 以前只有浏览器可以解析执行JavaScript代码\n   * 也就是说现在JavaScript可以完全脱离浏览器运行,一切归功于Node.js\n+ 浏览器中的JavaScript\n   * EcmaScript\n      - 基本的语法\n      - if\n      - var\n      - function\n      - Object\n      - Array\n   * BOM\n   * DOM\n+ Node.js中的JavaScript\n   * 没有BOM、DOM\n   * EcmaScript\n   * 在Node.js这个JavaScript执行环境中提供了一些服务器级别的操作API\n      - 例如文件读写\n      - 网络服务的构建\n      - 网络通信\n      - http服务器\n      - 等处理...\n+ 构建于Chrome的V8引擎之上\n   * 代码只是具有特定格式的字符串而已\n   * 引擎可以认识它,引擎可以帮助你去解析和执行\n   * Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快最高效的\n   * Node.js的作者把Google Chrome中的V8引擎移植了出来,开发了一个独立的JavaScript运行时环境\n+ Node.js特性：\n   * event-driven 事件驱动\n   * non-blocking I/O model 非阻塞IO模型(异步)\n   * lightweight and efficient 轻量和高效\n+ Node.js生态系统：\n    * npm:基于node.js开发的包管理工具\n    * npm是世界上最大的开源库生态系统\n    * 绝大多数JavaScript相关的包都存放在npm上,这样做的目的是为了让开发人员更方便下载使用\n    * `npm install jquery`\n### 1.3. Node.js能做什么？\n+ Web服务器\n+ 命令行工具\n   * npm(node)\n   * git(C语言)\n   * hexo(node)\n   * 。。。\n+ 对于前端开发工程师来讲,接触Node最多的是它的命令行工具\n   * 自己写的很少,主要是使用别人第三方的\n   * webpack、gulp、npm..\n\n### 1.4. 预备知识\n\n- HTML\n- CSS\n- JavaScript\n- 简单的命令行操作\n   * cd\n   * dir\n   * ls\n   * mkdir\n   * rm\n- 具有服务端开发经验\n\n### 1.5. 一些资源\n\n+ 《深入浅出Node.js》\n   * 朴灵\n   * 偏向理论原理，几乎没有任何实战内容\n   * 理解原理底层有帮助\n   * 结合学习实战去看\n+ 《Node.js权威指南》\n   * API讲解\n   * 也没有业务,没有实战\n+ 阮一峰javaScript标准参考教程(alpha):http://javascript.ruanyifeng.com/\n+ Node入门：https://www.nodebeginner.org/index-zh-cn.html\n+ 官方API文档:https://nodejs.org/en/docs/\n+ 中文文档:http://nodeclass.com/api/node.html\n+ CNODE社区：https://cnodejs.org/\n+ CNODE-新手入门:https://cnodejs.org/getstart\n\n### 1.6 Node.js学习内容\n+ B/S编程模型\n   * Browser-Server\n   * back-end\n   * 任何服务端技术,这种BS编程模型都是一样,和语言无关\n   * Node只是作为我们学习BS编程模型的一个工具而已\n+ 模块化编程\n   * RequireJS\n   * SeaJS\n   * `@import(`文件路径`)`\n   * 以前认知的JavaScript只能通过`script`标签来加载\n   * 在Node中可以像`@import()`一样来引用加载JavaScript脚本文件\n+ Node常用API\n+ 异步编程\n   * 回调函数\n   * Promise\n   * async\n   * generator\n+ Express Web 开发框架\n+ Ecmascript6\n   * Node常用的JavaScript新语法\n+ 学习Node不仅帮助服务端开发,同时会帮助学习前端高级内容\n   * Vue.js\n   * React\n   * Angular\n## 2.起步\n### 2.1. 安装Node环境\n+ 查看当前Node环境的版本号`node -v`\n+ 官网下载Node.js https://nodejs.org/en/\n+ 安装 \n+ 确定Node环境是否安装成功  命令行`node -v`\n+ 配置环境变量\n### 2.2 HelloWorld\n1.创建编写JavaScript脚本文件\n\t\t2.打开终端,定位到脚本文件所属目录\n\t\t3.输入`node 文件名`执行对应的文件\n注意:文件名不要使用`node.js`命名,不建议使用中文命名\n\n+ 解析执行JavaScript\n\n+ 读写文件\n\n+ http \n\n  最简单的http服务\n\n  ```HTML\n  // 使用Node创建一个http服务器\n  // 你可以使用Node非常轻松的构建一个Web服务器\n  // 在Node中专门提功力一个核心模块http\n  // http这个核心模块的职责就是帮你创建编写服务器的\n  \n  // 1.加载http核心模块\n  var http = require('http');\n  \n  // 2. 使用http.createSever()方法创建一个Web服务器\n  // 返回一个Server实例\n  var server = http.createServer();\n  \n  // 3.服务器要干嘛?\n  //      提供服务:对数据的服务\n  //      发送请求\n  //      接收请求\n  //      给个反馈(发送响应)\n  //      注册request请求事件\n  //      当客户端请求过来,就会自动触发服务器的request请求事件,然后执行第二个参数,回调处理函数\n  \n  server.on('request', function() {\n      console.log('收到客户端的请求了!');\n  })\n  \n  // 4.绑定端口号,启动服务器\n  server.listen(3000, function() {\n      console.log('服务器启动成功了,可以通过http://127.0.0.1:3000/ 来进行访问');\n  })\n  ```\n  \n## 3.Node中的JavaScript\n\n+ EcmaScript\n\n  - 没有DOM、BOM\n\n+ 核心模块\n\n+ 用户自定义模块\n\n+ 第三方模块\n\n### 3.1. EcmaScript\n\n### 3.2. 核心模块\n\n  Node为JavaScript提功了很多服务器级别的API,这些API绝大多数都被包装到了一个具名的核心模块中了。\n\n  例如文件操作的`fs`核心模块,http服务端构建的`http`模块,`path`路径操作模块、`os`操作系统信息模块等等。\n\n  只要一个模块是核心模块,若想使用它，必须：\n\n  ```HTML\n  var fs = require('fs')\n  var http = require('http')\n  ```\n\n### 3.3. 用户自定义模块\n\n  * require\n  * exports\n\n### 3.4. 第三方模块\n\n## 4.Web服务器开发\n\n### 4.1.ip地址和端口号\n\n+ ip地址是用来定位计算机\n\n+ 端口号用来定位具体的应用程序,一切需要联网通信的软件都会占用一个端口号\n\n+ 端口号的范围从0-65536之间\n\n+ 在计算机中有一些默认的端口号,最好不要去使用\n\n  - 如http服务的80端口\n  \n+ 我们开发过程中使用一些简单好记的端口号即可,如3000，5000等没有什么含义的\n\n+ 可以同时开启多个服务,但一定要确保不同服务占用的端口号不一致，一台计算机中，同一个端口号同一时间只能被一个程序占用\n\n### 4.2. Content-Type\n\n+ HTTP Mime-type    https://tool.oschina.net/commons \n\n+ 1.结合fs发送文件中的数据\n\n+ 2.Content-Type\n\n+ https://tool.oschina.net/commons \n\n+ 不同的资源对应的Content-Type是不一样的\n\n+ 图片不需要指定编码  一般只为字符数据才指定编码\n\n### 4.3. 服务端渲染和客户端渲染\n\n- 服务端渲染\n  + 说白了就是在服务端使用模板引擎\n  + 模板引擎最早诞生于服务端，后来才发展到了前端\n\n- 服务端渲染和客户端渲染的区别\n  + 客户端渲染不利于 SEO 搜索引擎优化\n  + 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的\n  + 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的\n  + 而是两者结合来做的\n  + 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化\n  + 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染\n\n### 4.3. 请求对象Request\n### 4.4. 响应对象Response\n### 4.5. 在Node中使用模板引擎\n### 4.6. 统一处理静态资源\n### 4.7. 服务端渲染\n\n## 5.留言板\n\n## 6.Node中的模板系统","tags":["Node.js"]},{"title":"HTML5知识点汇总","url":"/2020/03/17/HTML5知识点汇总/","content":"# HTML5\n\n## 概述\n\n### 文档类型设定\n\ndocument\n\n- HTML:\n- XHTML:\n- HTML5\n\n### 字符设定\n\n```HTML\n<meta http-equiv=\"charset\" content=\"utf-8\">：HTML与XHTML中建议这样去写\n<meta charset=\"utf-8\">：HTML5的标签中建议这样去写\n```\n\n## HTML5标签\n\n### 常用新标签\n\n- header：定义文档的页眉\n- nav：定义导航链接的部分\n- footer：定义文档或节的页脚\n- article：标签规定独立的自包含内容\n- section：定义文档中的节（section、区段）\n- aside：定义其所处内容之外的内容\n\n### 常用新属性\n\n\n| 属性             | 用法                                           | 含义                                        |\n| ---------------- | ---------------------------------------------- | ------------------------------------------- |\n| **placeholder**  | `<input type=\"text\" placeholder=\"请输入用户名\">` | 占位符提供可描述输入字段预期值的提示信息    |\n| **autofocus**    | `<input type=\"text\" autofocus>  `                | 规定当页面加载时 input 元素应该自动获得焦点 |\n| **multiple**     | `<input type=\"file\" multiple> `                  | 多文件上传                                  |\n| **autocomplete** |  `<input type=\"text\" autocomplete=\"off\">`        | 规定表单是否应该启用自动完成功能            |\n| **required**     | `<input type=\"text\" required>`                   | 必填项                                      |\n| **accesskey**    | `<input type=\"text\" accesskey=\"s\"> `             | 规定激活（使元素获得焦点）元素的快捷键      |\n\n### 新增的type属性值\n\n| 类型         | 使用示例                | 含义                 |\n| ------------ | ----------------------- | -------------------- |\n| **email**    | `<input type=\"email\">   ` | 输入邮箱格式         |\n| **tel**      | `<input type=\"tel\">     ` | 输入手机号码格式     |\n| **url**      | `<input type=\"url\">     ` | 输入url格式          |\n| **number**   | `<input type=\"number\">  ` | 输入数字格式         |\n| **search**   | `<input type=\"search\">  ` | 搜索框（体现语义化） |\n| **range**    | `<input type=\"range\">   ` | 自由拖动滑块         |\n| **time**     | `<input type=\"time\">    ` |                      |\n| **date**     | `<input type=\"date\">    ` |                      |\n| **datetime** | `<input type=\"datetime\">` |                      |\n| **month**    | `<input type=\"month\">   ` |                      |\n| **week**     | `<input type=\"week\">    ` |                      |\n\n### 综合案例\n\n```HTML\n`<form action=\"\">\n  <fieldset>\n    <legend>学生档案</legend>\n    <label for=\"userName\">姓名:</label>\n    <input type=\"text\" name=\"userName\" id=\"userName\" placeholder=\"请输入用户名\"> <br>\n    <label for=\"userPhone\">手机号码:</label>\n    <input type=\"tel\" name=\"userPhone\" id=\"userPhone\" pattern=\"^1\\d{10}$\"><br>\n    <label for=\"email\">邮箱地址:</label>\n    <input type=\"email\" required name=\"email\" id=\"email\"><br>\n    <label for=\"collage\">所属学院:</label>\n    <input type=\"text\" name=\"collage\" id=\"collage\" list=\"cList\" placeholder=\"请选择\"><br>\n\n    <datalist id=\"cList\">\n      <option value=\"前端与移动开发学院\"></option>\n      <option value=\"java学院\"></option>\n      <option value=\"c++学院\"></option>\n    </datalist><br>\n\n​    <label for=\"score\">入学成绩:</label>\n​    <input type=\"number\" max=\"100\" min=\"0\" value=\"0\" id=\"score\"><br>\n​    <label for=\"level\">基础水平:</label>\n​    <meter id=\"level\" max=\"100\" min=\"0\" low=\"59\" high=\"90\"></meter><br>\n​    <label for=\"inTime\">入学日期:</label>\n​    <input type=\"date\" id=\"inTime\" name=\"inTime\"><br>\n​    <label for=\"leaveTime\">毕业日期:</label>\n​    <input type=\"date\" id=\"leaveTime\" name=\"leaveTime\"><br>\n​    <input type=\"submit\">\n  </fieldset>\n</form>`\n```\n\n### 多媒体标签\n\n- embed：标签定义嵌入的内容\n- audio：播放音频\n- video：播放视频\n\n#### 多媒体embed\n\nembed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。\n\n因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 \n\n```HTML\n<embed src=\"http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n```\n\n#### 多媒体audio\n\nHTML5通过<audio>标签来解决音频播放的问题。\n\n使用相当简单，如下所示\n\n```HTML\n<!--通过src指定音频文件路径即可-->\n<audio src=\"1.mp3\"></audio>\n```\n\n并且可以通过附加属性可以更友好控制音频的播放，如：\n\nautoplay 自动播放\n\ncontrols 是否显不默认播放控件\n\nloop 循环播放\n\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考\n\n当前,audio元素支持三种音频格式:\n\n|            | IE9  | Firefox 3.5 | Opera 10.5 | Chrome 3.0 | Safari 3.0 |\n| ---------- | ---- | ----------- | ---------- | ---------- | ---------- |\n| Ogg Vorbis |      | √           | √          | √          |            |\n| MP3        | √    |             |            | √          | √          |\n| Wav        |      | √           | √          |            | √          |\n\n多浏览器支持方案,\n\n```HTML\n<audio controls>\n\t<!--通过src指定多格式音频文件-->\n    <audio src=\"1.mp3\"></audio>\n    <audio src=\"1.wav\"></audio>\n    <audio src=\"1.ogg\"></audio>\n    您的浏览器不支持HTML音频播放功能!\n</audio>\n```\n\n#### 多媒体video\n\n```HTML\nHTML5通过`<video>`标签来解决音频播放的问题。\n同音频播放一样，`<video>`使用也相当简单，如下所示\n<!--通过src指定音频文件路径即可-->\n<video src=\"1.mp4\" controls=\"controls\"></audio>\n```\n\n同样，通过附加属性可以更友好的控制视频的播放\n\nautoplay 自动播放\n\ncontrols 是否显示默认播放控件\n\nloop 循环播放\n\nwidth 设置播放窗口宽度\n\nheight 设置播放窗口的高度\n\n由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下供参考：\n\n当前,video元素支持三种视频格式:\n\n|       | IE   | Firefox 3.5 | Opera 10.5 | Chrome 3.0 | Safari 3.0 |\n| ----- | ---- | ----------- | ---------- | ---------- | ---------- |\n| Ogg   | No   | 3.5+        | 10.5+      | 5.0+       | No         |\n| MPEG4 | 9.0+ | No          | No         | 5.0+       | 3.0+       |\n| WebM  | No   | 4.0+        | 10.6+      | 6.0+       | No         |","tags":["HTML5"]},{"title":"CSS知识点汇总","url":"/2020/03/17/CSS知识点汇总/","content":"# 概述\n\nCSS(Cascading Style Sheets)\n\nCSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。\n\nCSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。\n\n## 样式规则\n\nCSS具体格式如下：\n\n![](CSS知识点汇总/css_1.png) \n\n```HTML\n在上面的样式规则中:\n1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。\n2.属性和属性值以“键值对”的形式出现。\n3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。\n4.属性和属性值之间用英文“:”连接。\n5.多个“键值对”之间用英文“;”进行区分。\n可以用段落 和 表格的对齐的演示。\n```\n\n## CSS注释\n\n```HTML\nCSS规则是使用     /*  需要注释的内容  */  进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。\n例如：\np {\n  font-size: 14px;                 /* 所有的字体是14像素大小*/\n}\n```\n\n\n\n# CSS样式属性\n\n## font-size:字号大小\n\nfont-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下：\n\n| 相对长度单位 | 说明                           |\n| ------------ | ------------------------------ |\n| em           | 相对于当前对象内文本的字体尺寸 |\n| px           | 像素,最常用                    |\n| 绝对长度单位 | 说明                           |\n| in           | 英寸                           |\n| cm           | 厘米                           |\n| mm           | 毫米                           |\n| pt           | 点                             |\n\n## font-family:字体\n\nfont-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码：\n\np{ font-family:\"微软雅黑\";}\n\n可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。\n\n```HTML\n1. 现在网页中普遍使用14px+。\n2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。\n3. 各种字体之间必须使用英文状态下的逗号隔开。\n4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。\n5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: \"Times New Roman\";。\n6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。\n```\n\n## CSS Unicode字体\n\n在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。\n\n方案一： 你可以使用英文来替代。 比如 font-family:\"Microsoft Yahei\"。\n\n方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。\nfont-family: \"\\5FAE\\8F6F\\96C5\\9ED1\"，表示设置字体为“微软雅黑”。\n\n可以通过escape()  来测试属于什么字体。\n\n| 字体名称    | 英文名称        | Unicode 编码         |\n| ----------- | --------------- | -------------------- |\n| 宋体        | SimSun          | \\5B8B\\4F53           |\n| 新宋体      | NSimSun         | \\65B0\\5B8B\\4F53      |\n| 黑体        | SimHei          | \\9ED1\\4F53           |\n| 微软雅黑    | Microsoft YaHei | \\5FAE\\8F6F\\96C5\\9ED1 |\n| 楷体_GB2312 | KaiTi_GB2312    | \\6977\\4F53_GB2312    |\n| 隶书        | LiSu            | \\96B6\\4E66           |\n| 幼园        | YouYuan         | \\5E7C\\5706           |\n| 华文细黑    | STXihei         | \\534E\\6587\\7EC6\\9ED1 |\n| 细明体      | MingLiU         | \\7EC6\\660E\\4F53      |\n| 新细明体    | PMingLiU        | \\65B0\\7EC6\\660E\\4F53 |\n\n## font-weight:字体粗细\n\n字体加粗除了用 b  和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的\n\nfont-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。数字 400 等价于 normal，而 700 等价于 bold。\n\n## font-style:字体风格\n\n字体倾斜除了用 i  和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。\n\nfont-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：\n\nnormal：默认值，浏览器会显示标准的字体样式。\n\nitalic：浏览器会显示斜体的字体样式。\n\noblique：浏览器会显示倾斜的字体样式。\n\n## font:综合设置字体样式 \n\n```HTML\nfont属性用于对字体样式进行综合设置，其基本语法格式如下：\n\n选择器{font: font-style  font-weight  font-size/line-height  font-family;}\n\n使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。\n注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。\n```\n\n# 选择器\n\n## 标签选择器\n\n标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下：\n\n```HTML\n标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }  或者\n元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }\n```\n\n标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。\n\n## 类选择器\n\n类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：\n\n```HTML\n.类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }\n 标签调用的时候用 class=“类名”  即可。\n类选择器最大的优势是可以为元素对象定义单独或相同的样式。\n1.长名称或词组可以使用中横线来为选择器命名。\n2.不建议使用“_”下划线来命名CSS选择器。\n3.不要纯数字、中文等命名， 尽量使用英文字母来表示。\n\n案例:谷歌logo\n<head>\n        <meta charset=\"utf-8\">\n        <style>\n        span {\n          font-size: 100px;\n        }\n        .blue {\n          color: blue;\n        }\n        .red {\n          color: red;\n        }\n        .orange {\n      color: orange;\n        }\n    .green {\n      color: green;\n    }\n        </style>\n    </head>\n    <body>\n      <span class=\"blue\">G</span>\n      <span class=\"red\">o</span>\n      <span class=\"orange\">o</span>\n      <span class=\"blue\">g</span>\n      <span class=\"green\">l</span>\n      <span class=\"red\">e</span>\n    </body>\n```\n\n## 多类名选择器\n\n```HTML\n我们可以给标签指定多个类名，从而达到更多的选择目的。\n注意:\n1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。\n2. 各个类名中间用空格隔开。\n例子:\n<div class=\"pink fontWeight font20\">亚瑟</div>\n<div class=\"font20\">刘备</div>\n<div class=\"font14 pink\">安其拉</div>\n<div class=\"font14\">貂蝉</div>\n```\n\n## id选择器\n\n```HTML\nid选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下：\n#id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }\n该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。id选择器用法基本和类选择器相同。\n\nid选择器和类选择器区别：\nW3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。\n```\n\n## 通配符选择器\n\n通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下：\n\n```HTML\n* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }\n例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。\n* {\n  margin: 0;                    /* 定义外边距*/\n  padding: 0;                   /* 定义内边距*/\n}\n```\n\n## 伪类选择器\n\n 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。\n\n```HTML\n为了和类选择器相区别，  类选择器是一个点 比如 .demo {}   而我们的伪类 用 2个点 就是 冒号  比如  :link{}\n```\n\n### 链接伪类选择器\n\n- :link      /* 未访问的链接 */\n- :visited   /* 已访问的链接 */\n- :hover     /* 鼠标移动到链接上 */\n- :active    /* 选定的链接 */\n\n\n   注意写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。\n\n```HTML\na {   /* a是标签选择器  所有的链接 */\n      font-weight: 700;\n      font-size: 16px;\n      color: gray;\n    }\na:hover {   /* :hover 是链接伪类选择器 鼠标经过 */\n      color: red; /*  鼠标经过的时候，由原来的 灰色 变成了红色 */\n}\n```\n\n### 结构(位置)伪类选择器（CSS3)\n\n- :first-child :选取属于其父元素的首个子元素的指定选择器\n- :last-child :选取属于其父元素的最后一个子元素的指定选择器\n- :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型\n- :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。\n  n 可以是数字、关键词或公式\n\n```HTML\nli:first-child { /*  选择第一个孩子 */\n            color: pink; \n          }\nli:last-child {   /* 最后一个孩子 */\n            color: purple;\n          }\nli:nth-child(4) {   /* 选择第4个孩子  n  代表 第几个的意思 */ \n        color: skyblue;\n          }\n```\n\n### 目标伪类选择器(CSS3)\n\n :target目标伪类选择器 :选择器可用于选取当前活动的目标元素\n\n```HTML\n:target {\n    color: red;\n    font-size: 30px;\n}\n```\n\n# CSS外观属性\n\n## color:文本颜色\n\ncolor属性用于定义文本的颜色，其取值方式有如下3种：\n\n1.预定义的颜色值，如red，green，blue等。\n\n2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。\n\n3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。\n\n需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。\n\n## line-height:行间距\n\nline-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际中使用最多的是像素px\n\n## text-align:水平对齐方式\n\ntext-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下：\n\nleft：左对齐（默认值）\n\nright：右对齐\n\ncenter：居中对齐\n\n## text-indent:首行缩进\n\ntext-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。\n\n1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度\n\n## letter-spacing:字间距\n\nletter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。\n\n## word-spacing:单词间距\n\nword-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。\n\nword-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。\n\n## 颜色半透明(css3)\n\n文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下：\n\n```HTML\n color: rgba(r,g,b,a)  a 是alpha  透明的意思  取值范围 0~1之间    color: rgba(0,0,0,0.3)  \n```\n\n### 文字阴影(CSS3)\n\n我们可以给我们的文字添加阴影效果了  Shadow  影子 \n\n```HTML\ntext-shadow:水平位置 垂直位置 模糊距离 阴影颜色;\ntext-shadow:3px 4px 5px rgba(0,0,0,.5);\n```\n\n| 值       | 描述                             |\n| -------- | -------------------------------- |\n| h-shadow | 必需。水平阴影的位置。允许负值。 |\n| v-shadow | 必需。垂直阴影的位置。允许负值。 |\n| blur     | 可选。模糊的距离。               |\n| color    | 可选。阴影的颜色。参阅CSS颜色值  |\n\n# 引入CSS样式表(书写位置)\n\n### 内部样式表\n\n```HTML\n内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：\n<head>\n<style type=\"text/CSS\">\n    选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}\n</style>\n</head>\n语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。\ntype=\"text/CSS\"  在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。\n```\n\n### 行内式（内联样式）\n\n```HTML\n内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下：\n<标签名 style=\"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;\"> 内容 </标签名>\n语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。\n```\n\n### 外部样式表（外链式）\n\n```HTML\n链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：\n<head>\n  <link href=\"CSS文件的路径\" type=\"text/CSS\" rel=\"stylesheet\" />\n</head>\n该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下：\nhref：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。\ntype：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。\nrel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。\n```\n\n### 三种样式表总结\n\n| 样式表     | 优点                     | 缺点                     | 使用情况       | 控制范围           |\n| ---------- | ------------------------ | ------------------------ | -------------- | ------------------ |\n| 行内样式表 | 书写方便，权重高         | 没有实现样式和结构相分离 | 较少           | 控制一个标签（少） |\n| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离             | 较多           | 控制一个页面（中） |\n| 外部样式表 | 完全实现结构和样式相分离 | 需要引入                 | 最多，强烈推荐 | 控制整个站点（多） |\n\n# 标签显示模式（display）\n\nHTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下：\n\n## 块级元素(block-level)\n\n```HTML\n每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。\n常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。\n 块级元素的特点：\n（1）总是从新行开始\n（2）高度，行高、外边距以及内边距都可以控制。\n（3）宽度默认是容器的100%\n（4）可以容纳内联元素和其他块元素。\n```\n\n## 行内元素(inline-level)\n\n```HTML\n行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。\n常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素。\n 行内元素的特点：\n（1）和相邻行内元素在一行上。\n（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。\n（3）默认宽度就是它本身内容的宽度。\n（4）行内元素只能容纳文本或则其他行内元素。（a特殊）\n注意：\n1. 只有文字才能组成段落.因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。\n2. 链接里面不能再放链接。\n```\n\n## 块级元素和行内元素区别\n\n```HTML\n块级元素的特点：\n（1）总是从新行开始\n（2）高度，行高、外边距以及内边距都可以控制。\n（3）宽度默认是容器的100%\n（4）可以容纳内联元素和其他块元素。\n行内元素的特点：\n（1）和相邻行内元素在一行上。\n（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。\n（3）默认宽度就是它本身内容的宽度。\n（4）行内元素只能容纳文本或则其他行内元素。\n\n```\n\n## 行内块元素（inline-block）\n\n```HTML\n在行内元素中有几个特殊的标签——<img />、<input />、<td>，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。\n行内块元素的特点：\n（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。\n（2）默认宽度就是它本身内容的宽度。\n（3）高度，行高、外边距以及内边距都可以控制。\n```\n\n## 标签显示模式转换 display\n\n```HTML\n块转行内：display:inline;\n行内转块：display:block;\n块、行内元素转换为行内块： display: inline-block;\n```\n\n# CSS复合选择器\n\n复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。\n\n## **交集选择器**\n\n交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。\n\n## **并集选择器**\n\n并集选择器（CSS选择器分组）是各个选择器通过<strong style=\"color:#f00\">逗号</strong>连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。如.class,h3。\n\n## **后代选择器**\n\n后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。如.class h3。\n\n## **子元素选择器**\n\n子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，这里的子指的是亲儿子不包含孙子重孙子之类。符号左右两侧各保留一个空格。如.class > h3。\n\n## **属性选择器**\n\n选取标签带有某些特殊属性的选择器 我们成为属性选择器\n\n```HTML\n/* 获取到 拥有 该属性的元素 */\ndiv[class^=font] { /*  class^=font 表示 font 开始位置就行了 */\n      color: pink;\n    }\ndiv[class$=footer] { /*  class$=footer 表示 footer 结束位置就行了 */\n      color: skyblue;\n    }\ndiv[class*=tao] { /* class*=tao  *=  表示tao 在任意位置都可以 */\n      color: green;\n    }\n<div class=\"font12\">属性选择器</div>\n    <div class=\"font12\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"24font\">属性选择器123</div>\n    <div class=\"sub-footer\">属性选择器footer</div>\n    <div class=\"jd-footer\">属性选择器footer</div>\n    <div class=\"news-tao-nav\">属性选择器</div>\n    <div class=\"news-tao-header\">属性选择器</div>\n    <div class=\"tao-header\">属性选择器</div>\n```\n\n## 伪元素选择器（CSS3)\n\n```HTML\n1. E::first-letter文本的第一个单词或字（如中文、日文、韩文等）\n2. E::first-line 文本第一行；\n3. E::selection 可改变选中文本的样式；\np::first-letter {\n  font-size: 20px;\n  color: hotpink;\n}\n\n/* 首行特殊样式 */\np::first-line {\n  color: skyblue;\n}\n\np::selection {\n  /* font-size: 50px; */\n  color: orange;\n}\n4、E::before和E::after\n在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。\ndiv::befor {\n  content:\"开始\";\n}\ndiv::after {\n  content:\"结束\";\n}\nE:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。\n\":\" 与 \"::\" 区别在于区分伪类和伪元素\n```\n\n# CSS书写规范\n\n## 空格规范\n\n```HTML\n【强制】 选择器 与 { 之间必须包含空格。\n示例： .selector { }\n【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。\n示例：\nfont-size: 12px;\n```\n\n## 选择器规范\n\n```html\n【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。\n示例：\n/* good */\n.post,\n.page,\n.comment {\n    line-height: 1.5;\n}\n\n/* bad */\n.post, .page, .comment {\n    line-height: 1.5;\n}\n【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。\n示例：\n/* good */\n#username input {}\n.comment .avatar {}\n\n/* bad */\n.page .header .login #username input {}\n.comment div * {}\n```\n\n## 属性规范\n\n```HTML\n【强制】 属性定义必须另起一行。\n示例：\n/* good */\n.selector {\n    margin: 0;\n    padding: 0;\n}\n\n/* bad */\n.selector { margin: 0; padding: 0; }\n【强制】 属性定义后必须以分号结尾。\n\n示例：\n/* good */\n.selector {\n    margin: 0;\n}\n\n/* bad */\n.selector {\n    margin: 0\n}\n```\n\n# CSS 背景(background)\n\nCSS 可以添加背景颜色和背景图片，以及来进行图片设置。\n\n| background-color                                            | 背景颜色         |\n| ----------------------------------------------------------- | ---------------- |\n| background-image                                            | 背景图片地址     |\n| background-repeat                                           | 是否平铺         |\n| background-position                                         | 背景位置         |\n| background-attachment                                       | 背景固定还是滚动 |\n| 背景的合写（复合属性）                                      |                  |\n| background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 |                  |\n\n## 背景图片(image)\n\n```html\n语法： background-image : none | url (url) \n参数： \nnone : 　无背景图（默认的）\nurl : 　使用绝对或相对地址指定背景图像 \nbackground-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复的话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。\n小技巧：  我们提倡 背景图片后面的地址，url不要加引号。\n```\n\n## 背景平铺（repeat）\n\n```HTML\n语法：background-repeat : repeat | no-repeat | repeat-x | repeat-y \n参数： \nrepeat : 　背景图像在纵向和横向上平铺（默认的）\nno-repeat : 　背景图像不平铺\nrepeat-x : 　背景图像在横向上平铺\nrepeat-y : 　背景图像在纵向平铺 \n设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。\n```\n\n## 背景位置(position)\n\n```html\n语法：background-position : length || length\nbackground-position : position || position \n参数： \nlength : 　百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位 \nposition : 　top | center | bottom | left | center | right \n说明： \n设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。\n如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。\n注意：\n1. position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。\n2. 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top;   则 15px 一定是  x坐标   top是 y坐标。\n实际用的最多的，就是背景图片居中对齐了。\n```\n\n## 背景附着\n\n```html\n语法：background-attachment : scroll | fixed \n参数： \nscroll : 　背景图像是随对象内容滚动\nfixed : 　背景图像固定 \n说明： \n设置或检索背景图像是随对象内容滚动还是固定的。\n```\n\n## 背景简写\n\n```html\nbackground属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：\nbackground:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置\nbackground: transparent url(image.png) repeat-y  scroll 50% 0 ;\n```\n\n## 背景透明(CSS3)\n\n```html\nCSS3支持背景半透明的写法语法格式是:background: rgba(0,0,0,0.3);\n 最后一个参数是alpha 透明度  取值范围 0~1之间\n 注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响。\n```\n\n### 背景缩放(CSS3)\n\n```html\n通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。\n其参数设置如下：\na) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）\nb) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多\nc) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。\nbackground-image: url('images/1.jpg');\n      background-size: 300px 100px;\n      /* background-size: contain; */\n      /* background-size: cover; */\n```\n\n## 多背景(CSS3)\n\n```html\n以逗号分隔可以设置多背景，可用于自适应布局  做法就是 用逗号隔开就好了。\n- 一个元素可以设置多重背景图像。 \n- 每组属性间使用逗号分隔。 \n- 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。\n- 为了避免背景色将图像盖住，背景色通常都定义在最后一组上。\nbackground:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px  ,\n     url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,\n     url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa;\n```\n\n### 凹凸文字案例\n\n```HTML\n<head>\n        <meta charset=\"utf-8\">\n        <style>\n        body {\n          background-color: #ccc;\n        }\n    div {\n      color: #ccc;\n      font: 700 80px \"微软雅黑\";\n    }\n    div:first-child {\n      /* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */\n      text-shadow: 1px 1px 1px #000, -1px -1px 1px #fff;\n    }\n    div:last-child {\n      /* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */\n      text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff;\n    }\n\n        </style>\n    </head>\n    <body>\n    <div>我是凸起的文字</div>\n    <div>我是凹下的文字</div>\n    </body>\n```\n\n## 文本的修饰\n\ntext-decoration   通常我们用于给链接修改装饰效果。\n\n| 值           | 描述                                          |\n| ------------ | --------------------------------------------- |\n| none         | 默认。定义标准的文本。                        |\n| underline    | 定义文本下的一条线。下划线 也是我们链接自带的 |\n| overline     | 定义文本上的一条线。                          |\n| line-through | 定义穿过文本下的一条线。                      |\n\n**使用技巧**：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。\n\n### 导航栏案例\n\n```php+HTML\n<head>\n        <meta charset=\"utf-8\">\n        <style>\n    body {\n      background-color: #000;\n    }\n    a {\n      width: 200px;\n      height: 50px;\n      /* background-color: orange; */\n      display: inline-block;  /* 把a 行内元素转换为行内块元素 */\n      text-align: center;  /* 文字水平居中 */\n      line-height: 50px;  /* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */\n      color: #fff;\n      font-size: 22px;\n      text-decoration: none;  /* 取消下划线 文本装饰 */\n    }\n    a:hover {  /* 鼠标经过 给我们的链接添加背景图片*/\n      background: url(images/h.png) no-repeat; \n    }\n        </style>\n    </head>\n    <body>\n    <a href=\"#\">专区说明</a>\n    <a href=\"#\">申请资格</a>\n    <a href=\"#\">兑换奖励</a>\n    <a href=\"#\">下载游戏</a>\n    </body>\n```\n\n# CSS三大特性\n\n层叠 继承  优先级 是我们学习CSS 必须掌握的三个特性。\n\n## CSS层叠性\n\n所谓层叠性是指多种CSS样式的叠加。是浏览器处理冲突的一个能力,如果一个属性通过两个选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉。比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。\n\n应用:恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）\n\n## CSS优先级\n\n定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。\n\n在考虑权重时，初学者还需要注意一些特殊的情况，具体如下：\n\n继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。\n\n行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。\n\n权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。\n\nCSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。\n\n## CSS特殊性（Specificity）\n\n关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：\n\nspecificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 \n\n| 继承或者* 的贡献值       | 0,0,0,0  |\n| ------------------------ | -------- |\n| 每个元素（标签）贡献值为 | 0,0,0,1  |\n| 每个类，伪类贡献值为     | 0,0,1,0  |\n| 每个ID贡献值为           | 0,1,0,0  |\n| 每个行内样式贡献值       | 1,0,0,0  |\n| 每个!important贡献值     | ∞ 无穷大 |\n\n比如的例子：\n\n```php+HTML\ndiv ul  li   ------>      0,0,0,3\n\n.nav ul li   ------>      0,0,1,2\n\na:hover      -----—>      0,0,1,1\n\n.nav a       ------>      0,0,1,1   \n\n#nav p       ----->       0,1,0,1\n```\n\n总结优先级：\n\n1. 使用了 !important声明的规则。\n2. 内嵌在 HTML 元素的 style属性里面的声明。\n3. 使用了 ID 选择器的规则。\n4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。\n5. 使用了元素选择器的规则。\n6. 只包含一个通用选择器的规则。\n\n总结：权重是优先级的算法，层叠是优先级的表现\n\n# 盒子模型（CSS重点）\n\nCSS就三个大模块：  盒子模型 、 浮动 、 定位，其余的都是细节。\n\n所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。\n\n## 盒子模型（Box Model）\n\n所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素在网页布局汇总所占的位置大小。因此，<strong style=\"color: #f00;\">每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。</strong>\n\n### 盒子边框（border）\n\n```html\n语法： border : border-width || border-style || border-color \n边框属性—设置边框样式（border-style）\n边框样式用于定义页面中边框的风格，常用属性值如下：\nnone：没有边框即忽略所有边框的宽度（默认值）\nsolid：边框为单实线(最为常用的)\ndashed：边框为虚线\ndotted：边框为点线\ndouble：边框为双实线\n```\n\n#### 表格的细线边框\n\n```php+HTML\n以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 \ntable{ border-collapse:collapse; }\nborder-collapse:collapse; 表示边框合并在一起。\n```\n\n#### 盒子边框总结表\n\n|              |                                                              |                                                              |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 设置内容     | 样式属性                                                     | 常用属性值                                                   |\n| 上边框       | border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; |                                                              |\n| 下边框       | border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; |                                                              |\n| 左边框       | border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; |                                                              |\n| 右边框       | border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; |                                                              |\n| 样式综合设置 | border-style:上边 [右边 下边 左边];                          | none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 |\n| 宽度综合设置 | border-width:上边 [右边 下边 左边];                          | 像素值                                                       |\n| 颜色综合设置 | border-color:上边 [右边 下边 左边];                          | 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)                 |\n| 边框综合设置 | border:四边宽度 四边样式 四边颜色;                           |                                                              |\n\n#### 圆角边框(CSS3)\n\n```html\nBorder-radius: 水平半径/垂直半径；\n一般我们垂直半径都是省略的默认和水平半径一样。\nborder-radius: 左上角  右上角  右下角  左下角;\n案例:\n<style>\n  div {\n    width:200px;\n    height:200px;\n    border:1px solid red;\n    margin:10px 40px;\n    text-align: center;\n    line-height: 200px;\n  }\n  div:first-child {\n    border:10px solid red;\n    border-radius: 20px/50px;\n  }\n  div:nth-child(2) {\n    border-radius: 20px;\n  }\n  div:nth-child(3) {\n    border-radius: 15px 0;\n  }\n  div:nth-child(4) {\n    border-radius:100px;\n  }\n  div:nth-child(5) {\n    border-radius: 50%;\n  }\n  div:nth-child(6) {\n    border-radius: 100px 0;\n  }\n  div:nth-child(7) {\n    border-radius: 200px 0 0 0;\n  }\n  div:nth-child(8) {\n    border-radius: 100px 100px 0 0;\n    height:100px;  /*高度减半*/\n  }\n  div:nth-child(9) {\n    border-radius: 100px;\n    height:100px;\n  }\n  div:nth-child(10) {\n    border-radius: 100%;\n    height:100px;\n  }\n</style\n```\n\n### 内边距（padding）\n\n```php+HTML\npadding属性用于设置内边距。  是指 边框与内容之间的距离。\npadding-top:上内边距\npadding-right:右内边距\npadding-bottom:下内边距\npadding-left:左内边距\n```\n\n| 值的个数 | 表达意思                                                     |\n| -------- | ------------------------------------------------------------ |\n| 1个值    | padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 |\n| 2个值    | padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 |\n| 3个值    | padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 |\n| 4个值    | padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 |\n\n### 外边距（margin）\n\n```HTML\nmargin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。\nmargin-top:上外边距\nmargin-right:右外边距\nmargin-bottom:下外边距\nmargin-left:上外边距\nmargin:上外边距 右外边距  下外边距  左外边\n取值顺序跟内边距相同。\n```\n\n#### 外边距实现盒子居中\n\n```HTML\n可以让一个盒子实现水平居中，需要满足一下两个条件：\n1. 必须是块级元素。     \n2. 盒子必须指定了宽度（width）\n然后就给左右的外边距都设置为auto，就可使块级元素水平居中。\n实际工作中常用这种方式进行网页布局，示例代码如下：\n.header{ width:960px; margin:0 auto;}\n```\n\n#### 清除元素的默认内外边距\n\n```HTML\n为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： \n* {\n   padding:0;         /* 清除内边距 */\n   margin:0;          /* 清除外边距 */\n}\n```\n\n#### 外边距合并\n\n使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。\n\n##### 相邻块元素垂直外边距的合并\n\n当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。\n\n![](CSS知识点汇总/css_2-1.png) \n\n解决方案：  避免就好了。\n\n##### 嵌套块元素垂直外边距的合并\n\n对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。\n\n![](CSS知识点汇总/css_2-2.png) \n\n解决方案：\n\n1. 可以为父元素定义1像素的上边框或上内边距。\n2. 可以为父元素添加overflow:hidden。\n\n## content宽度和高度\n\n```HTML\n使用宽度属性width和高度属性height可以对盒子的大小进行控制。\nwidth和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。\n大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：\n盒子的总宽度= width+左右内边距之和+左右边框宽度之和+左右外边距之和\n盒子的总高度= height+上下内边距之和+上下边框宽度之和+上下外边距之和\n注意：\n1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。\n2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。\n```\n\n## 盒子模型布局稳定性\n\n```HTML\n我们根据稳定性来分，建议如下：\n按照 优先使用宽度 （width）  其次 使用内边距（padding）再次外边距（margin）。\n  width >  padding  >   margin   \n原因：\n1. margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。\n2. padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。\n3. width   没有问题,我们经常使用宽度剩余法 高度剩余法来做。\n```\n\n## CSS3盒模型\n\n```HTML\nCSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。\n可以分成两种情况：\n1、box-sizing: border-box  盒子大小为 width\n2、box-sizing: content-box  盒子大小为 width + padding + border\n注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。\n\n- `content-box` 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。\n- `border-box` 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。\n- 注： `border-box`不包含`margin` \n```\n\n## 盒子阴影\n\n```HTML\n语法格式：box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色  内/外阴影；\n1. 前两个属性是必须写的。其余的可以省略。\n2. 外阴影 (outset) 不能写默认，想要内阴影  inset 未完成\nimg {\n  border:10px solid orange;\n  box-shadow:3px 3px 5px 4px rgba(0,0,0,1);\n}\n```\n\n| 值       | 描述                                   |\n| -------- | -------------------------------------- |\n| h-shadow | 必需。水平阴影的位置。允许负值。       |\n| v-shadow | 必需。垂直阴影的位置。允许负值。       |\n| blur     | 可选。模糊距离。                       |\n| spread   | 可选。阴影的尺寸                       |\n| color    | 可选。阴影的颜色。请参阅CSS颜色值。    |\n| inset    | 可选。将外部阴影(outset)改为内部阴影。 |\n\n# 浮动(float)\n\nCSS的定位机制有3种：普通流（标准流）、浮动和定位。\n\n## 普通流(normal flow)\n\nhtml语言当中另外一个相当重要的概念----------标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。\n\n## 浮动(float)\n\n浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。\n\n后来发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。\n\n元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。\n\n```HTML\n在CSS中，通过float属性来定义浮动，其基本语法格式如下： 选择器{float:属性值;}\n```\n\n| 属性值 | 描述                 |\n| ------ | -------------------- |\n| left   | 元素向左浮动         |\n| right  | 元素向右浮动         |\n| none   | 元素不浮动（默认值） |\n\n#### 浮动详细内幕特性\n\n浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找离它最近的父级元素对齐。但是不会超出内边距的范围。 \n\n![](CSS知识点汇总/css_3.png) \n\n浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。\n\n![](CSS知识点汇总/css_4.png) \n\n由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少。浮动根据元素书写的位置来显示相应的浮动。\n\n#### 清除浮动\n\n为什么要清除浮动？\n\n由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。\n\n清除浮动本质\n\n清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。\n\n![](CSS知识点汇总/css_5.png) \n\n![](CSS知识点汇总/css_6.png) \n\n#### 清除浮动的方法\n\n```HTML\n其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。\n在CSS中，clear属性用于清除浮动，其基本语法格式如下：选择器{clear:属性值;}\n```\n\n| 属性值 | 描述                                       |\n| ------ | ------------------------------------------ |\n| left   | 不允许左侧有浮动元素（清除左侧浮动的影响） |\n| right  | 不允许右侧有浮动元素（清除右侧浮动的影响） |\n| both   | 同时清除左右两侧浮动的影响                 |\n\n##### 额外标签法\n\n```html\n是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <div style=”clear:both”></div>，或则其他标签br等亦可。\n优点： 通俗易懂，书写方便\n缺点： 添加许多无意义的标签，结构化较差。\n```\n\n##### 父级添加overflow属性方法\n\n```HTML\n可以通过触发BFC的方式，可以实现清除浮动效果。\n可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。\n优点：  代码简洁\n缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。\n```\n\n##### 使用after伪元素清除浮动\n\n```+HTML\n使用方法：\n.clearfix:after {  content: \".\"; display: block; height: 0; clear: both; visibility: hidden;  }   \n.clearfix {*zoom: 1;}   /* IE6、7 专有 */\n优点： 符合闭合浮动思想  结构语义化正确\n缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。\n注意： content:\".\"  里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。\n```\n\n##### 使用before和after双伪元素清除浮动\n\n\n```HTML\n使用方法：\n.clearfix:before,.clearfix:after { \n  content:\".\";\n  display:table;\n}\n.clearfix:after {\n clear:both;\n}\n.clearfix {\n  *zoom:1;\n}\n优点：  代码更简洁\n缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。\n```\n\n## 定位(position)\n\n\n```HTML\n元素的定位属性主要包括定位模式和边偏移两部分。\n```\n\n1、边偏移\n\n| 边偏移属性 | 描述                                           |\n| ---------- | ---------------------------------------------- |\n| top        | 顶端偏移量，定义元素相对于其父元素上边线的距离 |\n| bottom     | 底部偏移量，定义元素相对于其父元素下边线的距离 |\n| left       | 左侧偏移量，定义元素相对于其父元素左边线的距离 |\n| right      | 右侧偏移量，定义元素相对于其父元素右边线的距离 |\n\n也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px;  left: 30px; 等等\n\n2、定位模式\n\n在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：\n\n选择器{position:属性值;}\n\nposition属性的常用值\n\n| 值       | 描述                                             |\n| -------- | ------------------------------------------------ |\n| static   | 自动定位（默认定位方式）                         |\n| relative | 相对定位，相对于其原文档流的位置进行定位         |\n| absolute | 绝对定位，相对于其上一个已经定位的父元素进行定位 |\n| fixed    | 固定定位，相对于浏览器窗口进行定位               |\n\n### 静态定位(static)\n\n静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。\n\n### 相对定位relative\n\n相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。\n\n对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示：\n\n![](CSS知识点汇总/css_7.png) \n\n注意：\n\n1. 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。\n2. 其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）\n\n就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）\n\n如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。\n\n就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。\n\n### 绝对定位absolute \n\n如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。\n\n当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。\n\n注意：    绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。\n\n##### 父级没有定位\n\n若所有父元素都没有定位，以浏览器为准对齐(document文档)。\n\n![](CSS知识点汇总/css_8.png) \n\n##### 父级有定位\n\n绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 \n\n![](CSS知识点汇总/css_9.png) \n\n##### 绝对定位的盒子没有边偏移 未完成\n\n如果只是给盒子指定了 定位，但是没有给边偏移，则该盒子以标准流来显示排序，和上一个盒子的底边对齐，但是不占有位置。\n\n![](CSS知识点汇总/css_10.png) \n\n##### 子绝父相\n\n因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。父盒子布局时，需要占有位置，因此父亲只能是相对定位。这就是子绝父相的由来。\n\n绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以）\n\n##### 绝对定位的盒子水平/垂直居中\n\n普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了\n\n定位的盒子也可以水平或者垂直居中，有一个算法。\n\n1. 首先left 50%   父盒子的一半大小\n\n2. 然后走自己外边距负的一半值就可以了 margin-left。\n\n## 固定定位fixed(认死理型)\n\n固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。\n\n当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。\n\n固定定位有两点：\n\n1. 固定定位的元素跟父亲没有任何关系，只认浏览器。\n2. 固定定位完全脱标，不占有位置，不随着滚动条滚动。\n\n## 叠放次序(z-index)\n\n当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。\n\n在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。\n\n比如：  z-index: 2;\n\n注意：\n\n1. z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。\n\n2. 如果取值相同，则根据书写顺序，后来居上。\n\n3. 后面数字一定不能加单位。\n\n4. 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。\n\n## 四种定位总结\n\n| 定位模式         | 是否脱标占有位置     | 是否可以使用边偏移 | 移动位置基准                     |\n| ---------------- | -------------------- | ------------------ | -------------------------------- |\n| 静态static       | 不脱标，正常模式     | 不可以             | 正常模式                         |\n| 相对定位relative | 不脱标，占有位置     | 可以               | 相对自身位置移动（自恋型）       |\n| 绝对定位absolute | 完全脱标，不占有位置 | 可以               | 相对于定位父级移动位置（拼爹型） |\n| 固定定位fixed    | 完全脱标，不占有位置 | 可以               | 相对于浏览器移动位置（认死理型） |\n\n## 定位模式转换\n\n跟浮动一样， 元素添加了绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式，\n\n因此,比如行内元素如果添加了绝对定位或者固定定位后/浮动后，可以不用转换模式，直接给高度和宽度就可以了。\n\n## 元素的显示与隐藏\n\n在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。\n\n他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告。\n\n### display 显示\n\ndisplay 设置或检索对象是否及如何显示。\n\ndisplay : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。\n\n特点： 隐藏之后，不再保留位置。\n\n### visibility 可见性\n\n设置或检索是否显示对象。\n\nvisible : 　对象可视\n\nhidden : 　对象隐藏\n\n特点： 隐藏之后，继续保留原有位置。\n\n### overflow 溢出\n\n检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。\n\nvisible : 　不剪切内容也不添加滚动条。\n\nauto : 　 超出自动显示滚动条，不超出不显示滚动条\n\nhidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉\n\nscroll : 　不管超出内容否，总是显示滚动条\n\n# CSS高级技巧\n\n## CSS用户界面样式\n\n所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。\n\n### 鼠标样式cursor\n\n```HTML\n 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。\ncursor :  default  小白 | pointer  小手  | move  移动  |  text  文本\n鼠标放上查看效果：\n<ul>\n  <li style=\"cursor:default\">我是小白</li>\n  <li style=\"cursor:pointer\">我是小手</li>\n  <li style=\"cursor:move\">我是移动</li>\n  <li style=\"cursor:text\">我是文本</li>\n</ul>\n尽量不要用hand  因为 火狐不支持     pointer ie6以上都支持的尽量用\n```\n\n### 轮廓 outline\n\n```HTML\n 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。\n outline : outline-color ||outline-style || outline-width \n但是我们都不关心可以设置多少，我们平时都是去掉的。\n最直接的写法是 ：  outline: 0; \n <input  type=\"text\"  style=\"outline: 0;\"/>\n```\n\n### 防止拖拽文本域resize\n\n\n```HTML\nresize：none    这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。\n右下角可以拖拽： <textarea></textarea>\n右下角不可以拖拽： <textarea  style=\"resize: none;\"></textarea>\n```\n\n### vertical-align 垂直对齐\n\n\n```HTML\nvertical-align : baseline |top |middle |bottom \n设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片和表单等。我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。\nbaseline:默认的是文字和图片基线对齐\nmiddle:默认的是文字和图片居中对齐\ntop：默认的是文字和图片顶部对齐\n```\n\n### 去除图片底侧空白缝隙\n\n```HTML\n有个很重要特性你要记住： 如果一个元素没有基线，比如图片或者表单等行内块元素，则他的底线会和父级盒子的基线对齐。</strong> 这样会造成一个问题，就是图片底侧会有一个空白缝隙。\n解决的方法就是：  \n1. 给img vertical-align:middle | top等等。  让图片不要和基线对齐。\n给img 添加 display：block; 转换为块级元素就不会存在问题了。\n```\n\n### 溢出的文字隐藏\n\n#### word-break:自动换行\n\nnormal   使用浏览器默认的换行规则。\n\nbreak-all   允许在单词内换行。\n\nkeep-all    只能在半角空格或连字符处换行。\n\n#### text-overflow 文字溢出\n\ntext-overflow : clip | ellipsis\n\n设置或检索是否使用一个省略标记（...）标示对象内文本的溢出\n\nclip : 　不显示省略标记（...），而是简单的裁切 \n\nellipsis : 　当对象内文本溢出时显示省略标记（...）\n\n## CSS精灵技术（sprite）\n\n图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。\n\n然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。\n\n### 精灵技术本质\n\n简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图\n\n### 精灵技术的使用\n\nCSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。\n\n### 制作精灵图\n\nCSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。\n\n  小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。\n\n### 案例：滑动门\n\n制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信官网首页导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？\n\n为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。\n\n![](CSS知识点汇总/css_12.png) \n\n```html\n核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。\n一般的经典布局都是这样的：\n<li>\n  <a href=\"#\">\n    <span>导航栏内容</span>\n  </a>\n</li>\n总结： \n\n1. a 设置 背景左侧，padding撑开合适宽度。    \n2. span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。\n3. 之所以a包含span就是因为 整个导航都是可以点击的。\n```\n\n## 字体图标\n\n图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的\"http请求\"，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面的移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了。 这就是字体图标（iconfont).\n\n### 字体图标优点\n\n可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...字体图标本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器，移动端设备必备良药...\n\n### 字体图标使用流程\n\n总体来说，字体图标按照如下流程：\n\n![](CSS知识点汇总/css_11.png) \n\n### 设计字体图标\n\n假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标之后保存为svg格式，然后给我们前端人员就好了。 \n\n  其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。\n\n### 上传生成字体包\n\n当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。\n\n​    推荐网站： http://icomoon.io\n\n**icomoon字库**\n\nIcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n\n   推荐网站： http://www.iconfont.cn/\n\n**阿里icon font字库**\n\nhttp://www.iconfont.cn/\n\n这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！\n\n**fontello**\n\n[http://fontello.com/](http://fontello.com/)\n\n在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。\n\n**Font-Awesome**\n\n[http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)\n\n这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。\n\n**Glyphicon Halflings**\n\n[http://glyphicons.com/](http://glyphicons.com/)\n\n这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。\n\n**Icons8**\n\n[https://icons8.com/](https://icons8.com/)\n\n提供PNG免费下载，像素大能到500px\n\n### 下载兼容字体包\n\n刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了\n\n当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。\n\n### 字体引入到HTML\n\n```HTML\n最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。\n1. 首先把 4个文件(.eot,.svg,.ttf,.woff)放入到 fonts文件夹里面。 通俗的做法\n第一步：引入项目下面生成的fontclass代码：\n<link rel=\"stylesheet\" type=\"text/CSS\" href=\"./iconfont.CSS\">\n第二步：挑选相应图标并获取类名，应用于页面：\n<i class=\"iconfont icon-xxx\"></i>\n```\n\n## 伸缩布局Flex(CSS3)\n\nCSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。\n\n主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向\n\n侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的\n\n方向：默认主轴从左向右，侧轴默认从上到下\n\n主轴和侧轴并不是固定不变的，通过flex-direction可以互换。\n\n![](CSS知识点汇总/css_13.png) \n\nFlex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多\n\n**各属性详解**\n\na、flex-direction调整主轴方向（默认为水平方向）\n\nb、justify-content调整主轴对齐\n\nc、align-items调整侧轴对齐\n\nd、flex-wrap控制是否换行\n\ne、align-content堆栈（由flex-wrap产生的独立行）对齐\n\nf、flex-flow是flex-direction、flex-wrap的简写形式\n\ng、flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配\n\nh、order控制子项目的排列顺序，正序方式排序，从小到大\n\n此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值\n\n## 过渡(CSS3)\n\n过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。\n\n在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。\n\n```HTML\n语法格式:\ntransition: 要过渡的属性  花费时间  运动曲线  何时开始;\n\n```\n\n| 属性                       | 描述                                         | CSS  |\n| -------------------------- | -------------------------------------------- | ---- |\n| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |\n| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |\n| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |\n| transition-timing-function | 规定过渡效果的时间曲线。默认是 \"ease\"。      | 3    |\n| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |\n\n未完成\n\n运动曲线示意图：\n\n```HTML\nimg {\n  width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%;\n  transition:transform 0.5s ease-in 0s;\n}\nimg:hover {\n  transform:rotate(180deg);\n}\n```\n\n## 2D变形(CSS3)\n\n```HTML\n转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。\n变形转换 transform  \n\n- 移动 translate(x, y) \ntranslate(50px,50px);\n使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。\n可以改变元素的位置，x、y可为负值；\n translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）\n translateX(x)仅水平方向移动（X轴移动）\n translateY(Y)仅垂直方向移动（Y轴移动）\n.box {\n  width: 499.9999px;\n  height: 400px;\n  background: pink;\n  position: absolute;\n  left:50%;\n  top:50%;\n  transform:translate(-50%,-50%);  /* 走的自己的一半 */\n}\n 让定位的盒子水平居中\n\n- 缩放 scale(x, y) \ntransform:scale(0.8,1);\n可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。\nscale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）\nscaleX(x)元素仅水平方向缩放（X轴缩放）\nscaleY(y)元素仅垂直方向缩放（Y轴缩放）\n scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大\n\n- 旋转 rotate(deg) \n可以对元素进行旋转，正值为顺时针，负值为逆时针；\ntransform:rotate(45deg);\n1. 当元素旋转以后，坐标轴也跟着发生的转变\n2. 调整顺序可以解决，把旋转放到最后\n3. 注意单位是 deg 度数\n案例旋转扑克牌\nbody {\n  background-color: skyblue;\n}\n.container {\n  width: 100px;\n  height: 150px;\n  border: 1px solid gray;\n  margin: 300px auto;\n  position: relative;\n}\n.container > img {\n  display: block;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  transform-origin: top right;\n  /* 添加过渡 */\n  transition: all 1s;\n}\n.container:hover img:nth-child(1) {\n  transform: rotate(60deg);\n}\n.container:hover img:nth-child(2) {\n  transform: rotate(120deg);\n}\n.container:hover img:nth-child(3) {\n  transform: rotate(180deg);\n}\n.container:hover img:nth-child(4) {\n  transform: rotate(240deg);\n}\n.container:hover img:nth-child(5) {\n  transform: rotate(300deg);\n}\n.container:hover img:nth-child(6) {\n  transform: rotate(360deg);\n}\n\n-倾斜 skew(deg, deg) \ntransform:skew(30deg,0deg);\n该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。\n可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。\ntransform-origin可以调整元素转换的原点\ndiv{transform-origin: left top;transform: rotate(45deg); }  /* 改变元素原点到左上角，然后进行顺时旋转45度 */    \n```\n\n## 3D变形\n\n左手坐标系\n\n伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度。\n\n```HTML\nrotateX() 就是沿着 x 立体旋转.\nimg {\n  transition:all 0.5s ease 0s;\n}\nimg:hove {\n\n  transform:rotateX(180deg);\n}\nrotateY() 沿着y轴进行旋转\nimg {\n  transition:all 0.5s ease 0s;\n}\nimg:hover {\n  transform:rotateX(180deg);\n}\nrotateZ()沿着z轴进行旋转\nimg {\n  transition:all .25s ease-in 0s;\n}\nimg:hover {\n  /* transform:rotateX(180deg); */\n  /* transform:rotateY(180deg); */\n  /* transform:rotateZ(180deg); */\n  /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */\n}\n```\n\n## 透视(perspective)\n\n电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。\n\n透视可以将一个2D平面，在转换的过程当中，呈现3D效果。\n\n注：并非任何情况下需要透视效果，根据开发需要进行设置。\n\nperspective有两种写法\n\n1. 作为一个属性，设置给父元素，作用于所有3D转换的子元素\n2. 作为transform属性的一个值，做用于元素自身\n\n```HTML\n开门案例\nbody {\n}\n.door {\n  width: 300px;\n  height: 300px;\n  margin: 100px auto;\n  border: 1px solid gray;\n  perspective: 1000px;\n  background: url('images/dog.gif') no-repeat center/cover;\n  position: relative;\n}\n.door > div {\n  box-sizing: border-box;\n  border: 1px solid black;\n}\n.left {\n  float: left;\n  width: 50%;\n  height: 100%;\n  background-color: brown;\n  transform-origin: left center;\n  transition: 1s;\n  position: relative;\n}\n.left::before {\n  content: '';\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  top: 50%;\n  right: 0px;\n  transform: translateY(-10px);\n  border: 1px solid whitesmoke;\n}\n.right {\n  width: 50%;\n  height: 100%;\n  float: left;\n  background-color: brown;\n  transform-origin: right center;\n  transition: 1s;\n  position: relative;\n}\n.right::before {\n  content: '';\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  top: 50%;\n  left: 0px;\n  transform: translateY(-10px);\n  border: 1px solid whitesmoke;\n}\n.door:hover .left {\n  transform: rotateY(-130deg);\n}\n.door:hover .right {\n  transform: rotateY(130deg);\n}\n```\n\n## 位移\n\ntranslateX(x)：仅水平方向移动**（X轴移动）\n\ntranslateY(y)：仅垂直方向移动**（Y轴移动）\n\ntranslateZ(z)：仅Z轴方向移动**（Z轴移动）\n\n```HTML\ntransformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了。\n```\n\n## 3D呈现（transform-style）\n\n设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为转换原素。\n\nflat：所有子元素在 2D 平面呈现\n\npreserve-3d：保留3D空间\n\n3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。\n\n一般而言，该声明应用在3D变换的兄弟元素们的父元素上。\n\n```HTML\n翻转盒子案例(百度钱包)\nbody {\n  margin: 0;\n  padding: 0;\n  background-color: #B3C04C;\n\n}\n\n.wallet {\n  width: 300px;\n  height: 300px;\n  margin: 50px auto;\n  position: relative;\n  transform-style: preserve-3d;\n  transition: all 0.5s;\n}\n\n.wallet::before, .wallet::after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-image: url(./images/bg.png);\n  background-repeat: no-repeat;\n}\n\n.wallet::before {\n  background-position: right top;\n  transform: rotateY(180deg);\n}\n\n.wallet::after {\n  background-position: left top;\n  transform: translateZ(2px);\n}\n\n.wallet:hover {\n  transform: rotateY(180deg);\n}\n```\n\n### 动画(CSS3)\n\n```HTML\n动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。\n语法格式：animation:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;\n```\n\n| 属性                      | 描述                                                   | CSS  |\n| ------------------------- | ------------------------------------------------------ | ---- |\n| @keyframes                | 规定动画                                               | 3    |\n| animation                 | 所有动画属性的简写属性，除了animation-play-state属性。 | 3    |\n| animation-name            | 规定@keyframes动画的名称                               | 3    |\n| animation-duration        | 规定完成一个周期所花费的秒或毫秒。默认是0。            | 3    |\n| animation-timing-function | 规定动画的速度曲线。默认是\"ease\"。                     | 3    |\n| animation-delay           | 规定动画何时开始。默认是0。                            | 3    |\n| animation-itration-count  | 规定动画被播放的次数。默认是1。                        | 3    |\n| animation-direction       | 规定动画是否在下一周期逆向地播放。默认是\"normal\"。     | 3    |\n| animation-play-state      | 规定动画是否正在运行或暂停。默认是\"running\"。          | 3    |\n| animation-fill-mode       | 规定对象动画时间之外的状态                             | 3    |\n\n关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意\n\n```HTML\n@keyframes 动画名称 {\n  from{ 开始位置 }  0%\n  to{  结束  }  100%\n}\nanimation-iteration-count:infinite;  无限循环播放\nanimation-play-state:paused;   暂停动画\"\n\n小汽车案例\n\nbody {\n  background: white;\n}\nimg {\n  width: 200px;\n}\n.animation {\n  animation-name: goback;\n  animation-duration: 5s;\n  animation-timing-function: ease;\n  animation-iteration-count: infinite;\n}\n@keyframes goback {\n  0%{}\n  49%{\n    transform: translateX(1000px);\n  }\n  55%{\n    transform: translateX(1000px) rotateY(180deg);\n  }\n  95%{\n    transform: translateX(0) rotateY(180deg);\n  }\n  100%{\n    transform: translateX(0) rotateY(0deg);\n  }\n}\n\n```\n","tags":["CSS"]},{"title":"HTML知识点汇总","url":"/2020/03/17/HTML知识点汇总/","content":"# web 概述\n\n## 常见浏览器简介\n\n```\n浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。\n```\n\n## 浏览器内核\n\n```\n浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。\n渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。\nJS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。\n\n最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。\n```\n\n（1）Trident(IE 内核)\n\n国内很多的双核浏览器的其中一核便是 Trident，美其名曰 \"兼容模式\"。\n\n代表： IE、傲游、世界之窗浏览器、Avant、腾讯 TT、猎豹安全浏览器、360 极速浏览器、百度浏览器等。\n\nWindow10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。\n\n（2）Gecko(firefox)\n\nGecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友 flash、神一样的对手 chrome。\n\n（3） webkit(Safari)\n\nSafari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。\n\n现在很多人错误地把 webkit 叫做 chrome 内核（即使 chrome 内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。\n\n代表浏览器：傲游浏览器 3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian 手机浏览器、Android 默认浏览器，\n\n（4） Chromium/Bink(chrome)\n\n在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。\n\n     大部分国产浏览器最新版都采用Blink内核。\n\n（5） Presto(Opera)\n\nPresto 是挪威产浏览器 opera 的 \"前任\" 内核，为何说是 \"前任\"，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。\n\n移动端的浏览器内核主要说的是系统内置浏览器的内核。\n\n目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。\n\n## 路径\n\n路径可以分为： 相对路径和绝对路径\n\n### 绝对路径\n\n“D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.github.com/images/logo.gif”。\n\n### 相对路径\n\n1. 图像文件和 HTML 文件位于同一文件夹：./（推荐）或者只需输入图像文件的名称即可，如<img src=\"./logo.gif\"> ; &lt;img src=\"logo.gif\" /&gt;。\n2. 图像文件位于 HTML 文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=\"img/img01/logo.gif\" /&gt;。\n3. 图像文件位于 HTML 文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=\"../logo.gif\" /&gt;。\n\n# HTML\n\n## 概述\n\nHTML（英文 Hyper Text Markup Language 的缩写）中文译为“超文本标签语言”，主要是通过 HTML 标签对网页中的文本、图片、声音等内容进行描述。\n\n### 骨架\n\n```HTML\n<HTML>\n    <head>\n        <title></title>\n    </head>\n    <body>\n    </body>\n</HTML>\n1 HTML标签：\n\n作用所有HTML中标签的一个根节点。\n\n2 head标签：\n\n作用：用于存放：\n\ntitle,meta,base,style,script,link\n\n注意在head标签中我们必须要设置的标签是title\n\n3.title标签：\n\n作用：让页面拥有一个属于自己的标题。\n\n4.body标签：\n\n作用：页面在的主体部分，用于存放所有的HTML标签：\n\np,h,a,b,u,i,s,em,del,ins,strong,img\n```\n\n### HTML 标签分类\n\n单标签: 在 HTML 基础中，单标签就是由一个标签组成的。例如`<br>、<hr>、<img>、<input>、<param>、<meta>、<link>`。\n\n双标签: 而双标签则是由“开始标签”和“结束标签”两部分构成（这两部分是相同的）。例如`<html>、<head>、<title>、<body>、<table>、<tr>、<td>、<span>、<p>、<form>、<h1>、<h2>、<h3>、<h4>、<h5>、<h6>、<object>、<style>、<b>、<u>、<strong>、<i>、<div>、<a>、<script>、<center>`（双标签的一部分）。\n\n### HTML 标签关系\n\n标签的相互关系就分为两种：1.嵌套关系 2.并列关系\n\n### 开发工具\n\nWebStorm,VSCode,HBuilderX, Dreamweaver,Sublime\n\n### 文档类型<!DOCTYPE>\n\n这句话就是告诉我们使用哪个 html 版本？ 我们使用的是 html 5 的版本。 html 有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。\n\n<!DOCTYPE> 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用<!DOCTYPE>标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。\n\n注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML 之类的，但是我们学的是 HTML5,而且 HTML5 的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用 HTML5 的文档类型就好了。\n\n### 字符集\n\n```HTML\n<meta charset=\"UTF-8\">\n```\n\nutf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。\n\ngb2312 简单中文 包括 6763 个汉字\n\nBIG5 繁体中文 港澳台等用\n\nGBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312\n\nUTF-8 则包含全世界所有国家需要用到的字符\n\n我们统统使用 UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。\n\n### HTML 标签的语义化\n\n所谓标签语义化，就是指通过 html 标签的内容可了解其含义。\n\nHTML 标签语义化的优点:\n\n1. 方便代码的阅读和维护\n\n2. 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容\n\n3. 使用语义化标签会具有更好地搜索引擎优化\n\n核心：合适的地方给一个最为合理的标签。\n\n语义是否良好： 当我们去掉 CSS 之后，网页结构依然组织有序，并且有良好的可读性。\n\n不管是谁都能看懂这块内容是什么。\n\n遵循的原则：先确定语义的 HTML ，再选合适的 CSS。\n\n### 标签属性\n\n使用 HTML 制作网页时，如果想让 HTML 标签提供更多的信息，可以使用 HTML 标签的属性加以设置。其基本语法格式如下：\n\n```html\n<标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …> 内容 </标签名>\n```\n\n在上面的语法中，\n\n1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。\n\n2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。\n\n3.任何标签的属性都有默认值，省略该属性则取默认值。\n\n采取 键值对 的格式 key=\"value\" 的格式\n\n## HTML 标签\n\n### 排版标签\n\n| 标签名   | 语义       | 格式            |\n| -------- | ---------- | --------------- |\n| 水平线   | horizontal | `<hr />`        |\n| 换行     | break      | `<break/>`      |\n| **div**  | division   | `<div> </div>`  |\n| **span** | /          | `<span></span>` |\n\n### 文本格式化标签\n\n\n| 标签名 | 语义化      | 格式                       | 备注              |\n| ------ | ----------- | -------------------------- | ----------------- |\n| 粗体   | bold/strong | `<b></b><strong></strong>` | XHTML 推荐 strong |\n| 斜体   | /           | `<i></i><em></em>`         | XHTML 推荐 em     |\n| 删除线 | /           | `<s></s><del></del>`       | XHTML 推荐 del    |\n| 下划线 | /           | `<u></u><ins></ins>`       | XHTM 不赞成使用 u |\n\n### 图像标签 img\n\n单词缩写： image 图像\n\nHTML 网页中任何元素的实现都要依靠 HTML 标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<img />以及和他相关的属性。其基本语法格式如下：\n\n该语法中 src 属性用于指定图像文件的路径和文件名，他是 img 标签的必需属性。\n\n```HTML\n<img src=\"图像URL\" />\n```\n\n`<img/>`标签属性 \n\n| 属性   | 属性值                          | 描述                     |\n| ------ | ------------------------------- | ------------------------ |\n| src    | URL                             | 图像的路径               |\n| alt    | 文本                            | 图像不能显示时的替换文本 |\n| title  | 文本                            | 鼠标悬停时显示的内容     |\n| width  | 像素（XHTML 不支持%页面百分比） | 设置图片的宽度           |\n| height | 像素（XHTML 不支持%页面百分比） | 设置图片的高度           |\n| border | 数字                            | 设置图像边框的宽度       |\n\n### 链接标签 a\n\n#### 基础\n\n单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的\n\n在 HTML 中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下：\n\n```HTML\n<a href=\"跳转目标\" target=\"目标窗口的弹出方式\">文本或图像</a>\n```\n\nhref：用于指定链接目标的 url 地址，当为标签应用 href 属性时，它就具有了超链接的功能。 Hypertext Reference 的缩写。意思是超文本引用\n\ntarget：用于指定链接页面的打开方式，其取值有\\_self 和\\_blank 两种，其中\\_self 为默认值，\\_blank 为在新窗口中打开方式。\n\n注意：\n\n1.外部链接 需要添加 http:// www.baidu.com\n\n2.内部链接 直接链接内部页面名称即可 比如 < a href=\"index.html\"> 首页 </a >\n\n3.如果当时没有确定链接目标时，通常将链接标签的 href 属性值定义为“#”(即 href=\"#\")，表示该链接暂时为一个空链接。\n\n4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。\n\n##### 防止页面跳转的方式\n\n```HTML\n1、<a href=\"#\" >test</a>；\n\n点击链接，页面默认上滚到页的顶部， 但可以加上 onclick=\"return false\"，防止上滚到页的顶部。\n\n2、<a href=\"####\" >test</a>；\n\n使用2个到4个#，见的大多是\"####\"，也有使用\"#all\"等其他的。一个无意义的标签指定，不做任何处理。\n\n3、<a href=\"javascript：void(0);\" >test</a>；\n<a href=\"javascript：;\" >test</a>；\n\njavascript:void(0) /javascript：;表示一个死链接，执行空事件。\n```\n\n#### 锚点定位\n\n通过创建锚点链接，用户能够快速定位到目标内容。\n创建锚点链接分为两步：\n\n```HTML\n1.使用“a href=”#id名>“链接文本\"</a>创建链接文本。\n\n2.使用相应的id名标注跳转目标的位置。\n```\n\n### base 标签\n\nbase 可以设置整体链接的打开状态 ，其取值有\\_self 和\\_blank 两种，其中\\_self 为默认值，\\_blank 为在新窗口中打开方式。\n\nbase 写到 <head> </head> 之间\n\n### 常用转义字符\n\n| 特殊字符 | 描述     | 字符的代码 |\n| -------- | -------- | ---------- |\n|          | 空格符   | `&nbsp;`   |\n| ＜       | 小于号   | `&lt;`     |\n| ＞       | 大于号   | `&gt;`     |\n| ＝       | 和号     | `&amp;`    |\n| ￥       | 人民币   | `&yen;`    |\n| ©        | 版权     | `&copy;`   |\n| ®        | 注册商标 | `&reg;`    |\n| °        | 摄氏度   | `&deg;`    |\n| ±        | 正负号   | `&plusmn;` |\n| ×        | 乘号     | `&times;`  |\n| ÷        | 除号     | `&divide;` |\n| ²        | 平方     | `&sup2;`   |\n| ³        | 立方     | `&sup3;`   |\n\n### 注释标签\n\n在 HTML 中还有一种特殊的标签——注释标签。如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：\n\n```HTML\n    <!-- 注释语句 -->\n```\n\n### 列表标签\n\n#### 无序列表 ol\n\n无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：\n\n```HTML\n<ul>\n  <li>列表项1</li>\n  <li>列表项2</li>\n  <li>列表项3</li>\n  ......\n</ul>\n```\n\n注意：\n\n```HTML\n 1. <ul></ul>中只能嵌套<li></li>，直接在<ul></ul>标签中输入其他标签或者文字的做法是不被允许的。\n 2. <li>与</li>之间相当于一个容器，可以容纳所有元素。\n 3. 无序列表会带有自己样式属性，可以让CSS来修改样式！\n```\n\n#### 有序列表 ol\n\n有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：\n\n```HTML\n<ol>\n  <li>列表项1</li>\n  <li>列表项2</li>\n  <li>列表项3</li>\n  ......\n</ol>\n```\n\n#### 自定义列表\n\n常用在网站底部设计,定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：\n\n```HTML\n<dl>\n  <dt>名词1</dt>\n  <dd>名词1解释1</dd>\n  <dd>名词1解释2</dd>\n  ...\n  <dt>名词2</dt>\n  <dd>名词2解释1</dd>\n  <dd>名词2解释2</dd>\n  ...\n</dl>\n```\n\n### 表格标签 table\n\n#### 表格结构\n\n在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：\n\n```HTML\n<thead></thead>：用于定义表格的头部。\n\n必须位于<table></table> 标签中，一般包含网页的logo和导航等头部信息。\n\n\n<tbody></tbody>：用于定义表格的主体。\n\n位于<table></table>标签中，一般包含网页中除头部和底部之外的其他内容。\n```\n\n#### 基本语法\n\n在 HTML 网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下：\n\n```HTML\n<table>\n  <tr>\n    <td>单元格内的文字</td>\n    ...\n  </tr>\n  ...\n</table>\n```\n\n在上面的语法中包含三对 HTML 标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释。\n\n```HTML\n1.table用于定义一个表格。\n\n2.tr 用于定义表格中的一行，必须嵌套在 table /table标签中，在 table /table中包含几对 tr /tr，就有几行表格。\n\n3.td /td：用于定义表格中的单元格，必须嵌套在<tr></tr>标签中，一对 <tr> </tr>中包含几对<td></td>，就表示该行中有多少列（或多少个单元格）。\n```\n\n注意:\n\n```HTML\n1. <tr></tr>中只能嵌套<td></td>\n2. <td></td>标签，他就像一个容器，可以容纳所有的元素\n```\n\n#### 表格属性\n\n| 属性名      | 含义                                     | 常用属性值          |\n| ----------- | ---------------------------------------- | ------------------- |\n| border      | 设置表格的边框(默认 border=\"0\"无边框)    | 像素值              |\n| cellspacing | 设置单元格与单元格之间的空白间距         | 像素值(默认为 2px)  |\n| callpadding | 设置单元格内容与单元格边框之间的空白间距 | 像素值(默认为 1px)  |\n| width       | 设置表格的宽度                           | 像素值              |\n| height      | 设置表格的高度                           | 像素值              |\n| align       | 设置表格在网页中的水平对齐方式           | left、center、right |\n\n#### 表头标签\n\n表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。\n\n#### 合并单元格\n\n跨行合并：rowspan 跨列合并：colspan\n\n### 表单标签 input\n\n在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。\n\n表单控件：\n\n       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。\n\n提示信息：\n\n        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。\n\n表单域：\n\n      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。\n\n#### input 属性\n\n<table>\n\t<tr>\n\t    <th>属性</th>\n\t    <th>属性值</th>\n\t    <th>描述</th>  \n\t</tr >\n\t<tr >\n\t    <td rowspan=\"9\">type</td>\n\t    <td>text</td>\n\t    <td>单行文本输入框</td>\n\t</tr>\n\t<tr>\n\t    <td>password</td>\n\t    <td>密码输入框</td>\n\t</tr>\n\t<tr>\n\t    <td>radio</td>\n\t    <td>单选按钮</td>\n\t</tr>\n\t<tr>\n\t    <td>CheckBox</td>\n\t    <td>复选按钮</td>\n\t</tr>\n\t<tr><td>button</td>\n\t    <td>普通按钮</td>\n\t</tr>\n\t<tr>\n\t    <td>submit</td>\n\t    <td>提交按钮</td>\n\t</tr>\n\t<tr>\n\t    <td>reset</td>\n\t    <td>重置按钮</td>\n\t</tr>\n\t<tr>\n\t    <td>image</td>\n\t    <td>图像形式的提交按钮</td>\n\t</tr>\n\t<tr>\n\t    <td >file</td>\n\t    <td>文件域</td>\n\t</tr>\n\t<tr>\n\t    <td >name</td>\n\t    <td>用户自定义</td>\n\t    <td>控件名称</td>\n\t</tr>\n\t<tr>\n\t    <td >value</td>\n\t    <td >用户自定义</td>\n\t    <td >默认文本值</td>\n\t</tr>\n\t<tr>\n\t    <td >size</td>\n\t    <td >正整数</td>\n\t    <td >控件在页面中的显示宽度</td>\n\t</tr>\n\t<tr>\n\t    <td >checked</td>\n\t    <td >checked</td>\n\t    <td >定义选择控件默认被选中项</td>\n\t</tr>\n\t<tr>\n\t    <td >maxlength</td>\n\t    <td >正整数</td>\n\t    <td >控件允许输入的最多字符</td>\n\t</tr>\n</table>\n\n#### 标签 label\n\nlabel 标签为 input 元素定义标注（标签）。\n\n作用： 用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点\n\n如何绑定元素呢？\n\nfor 属性规定 label 与哪个表单元素绑定。\n\n```HTML\n<label for=\"male\">Male</label>\n<input type=\"radio\" name=\"sex\" id=\"male\" value=\"male\">\n```\n\n#### 文本域 textarea\n\n如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过 textarea 控件可以轻松地创建多行文本输入框，其基本语法格式如下：\n\n```HTML\n<textarea cols=\"每行中的字符数\" rows=\"显示的行数\">\n  文本内容\n</textarea>\n```\n\n#### 下拉菜单 select\n\n使用 select 控件定义下拉菜单的基本语法格式如下:\n\n```HTML\n<select>\n  <option>选项1</option>\n  <option>选项2</option>\n  <option>选项3</option>\n  ...\n</select>\n```\n\n注意：\n\n1. &lt;select&gt;</select&gt;中至少应包含一对&lt;option></option&gt;。\n2. 在 option 中定义 selected =\" selected \"时，当前项即为默认选中项。\n\n#### 表单域\n\n在 HTML 中，form 标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form 中的所有内容都会被提交给服务器。创建表单的基本语法格式如下：\n\n```HTML\n<form action=\"url地址\" method=\"提交方式\" name=\"表单名称\">\n  各种表单控件\n</form>\n```\n\n常用属性：\n\n1. Action\n   在表单收集到信息后，需要将信息传递给服务器进行处理，action 属性用于指定接收并处理表单数据的服务器程序的 url 地址。\n2. method\n   用于设置表单数据的提交方式，其取值为 get 或 post。\n3. name\n   用于指定表单的名称，以区分同一个页面中的多个表单。\n\n注意： 每个表单都应该有自己表单域。\n","tags":["HTML"]}]